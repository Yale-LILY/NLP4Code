{"data_file": "data/spider/train_spider_processed_v2.jsonl", "total_num_examples": 6997, "annotation_indices": [840, 38, 6781, 2630, 4973, 1958, 3702, 4578, 2661, 2410, 749, 59, 6185, 4039, 5441, 5697, 2550, 482, 5657, 4034, 6301, 6888, 3996, 538, 5597, 328, 1967, 1841, 2725, 6218, 5937, 6095, 2668, 1389, 2685, 6000, 2906, 6456, 4265, 6259, 649, 5164, 3853, 1348, 2480, 2158, 3213, 1930, 1183, 3877, 604, 5064, 2286, 624, 2397, 4923, 148, 1729, 4350, 2798, 5283, 1198, 2108, 1965, 1563, 648, 1240, 5979, 3598, 463, 5807, 4217, 5343, 5708, 5783, 552, 2345, 2990, 3495, 6226, 2794, 2159, 1231, 5378, 2988, 4932, 311, 3254, 4478, 3740, 6368, 1979, 507, 3353, 4281, 3460, 2143, 2808, 1111, 168]}
{"metadata": {"db_id": "chinook_1", "query": "SELECT T1.Title ,  T2.AlbumID FROM ALBUM AS T1 JOIN TRACK AS T2 ON T1.AlbumId  =  T2.AlbumId WHERE T2.UnitPrice  >  1 GROUP BY T2.AlbumID", "query_toks": ["SELECT", "T1.Title", ",", "T2.AlbumID", "FROM", "ALBUM", "AS", "T1", "JOIN", "TRACK", "AS", "T2", "ON", "T1.AlbumId", "=", "T2.AlbumId", "WHERE", "T2.UnitPrice", ">", "1", "GROUP", "BY", "T2.AlbumID"], "query_toks_no_value": ["select", "t1", ".", "title", ",", "t2", ".", "albumid", "from", "album", "as", "t1", "join", "track", "as", "t2", "on", "t1", ".", "albumid", "=", "t2", ".", "albumid", "where", "t2", ".", "unitprice", ">", "value", "group", "by", "t2", ".", "albumid"], "question": "What are the titles and ids for albums containing tracks with unit price greater than 1?", "question_toks": ["What", "are", "the", "titles", "and", "ids", "for", "albums", "containing", "tracks", "with", "unit", "price", "greater", "than", "1", "?"], "sql": {"from": {"table_units": [["table_unit", 0], ["table_unit", 10]], "conds": [[false, 2, [0, [0, 1, false], null], [0, 58, false], null]]}, "select": [false, [[0, [0, [0, 2, false], null]], [0, [0, [0, 58, false], null]]]], "where": [[false, 3, [0, [0, 64, false], null], 1.0, null]], "groupBy": [[0, 58, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Album": ["AlbumId", "Title", "ArtistId"], "Artist": ["ArtistId", "Name"], "Customer": ["CustomerId", "FirstName", "LastName", "Company", "Address", "City", "State", "Country", "PostalCode", "Phone", "Fax", "Email", "SupportRepId"], "Employee": ["EmployeeId", "LastName", "FirstName", "Title", "ReportsTo", "BirthDate", "HireDate", "Address", "City", "State", "Country", "PostalCode", "Phone", "Fax", "Email"], "Genre": ["GenreId", "Name"], "Invoice": ["InvoiceId", "CustomerId", "InvoiceDate", "BillingAddress", "BillingCity", "BillingState", "BillingCountry", "BillingPostalCode", "Total"], "InvoiceLine": ["InvoiceLineId", "InvoiceId", "TrackId", "UnitPrice", "Quantity"], "MediaType": ["MediaTypeId", "Name"], "Playlist": ["PlaylistId", "Name"], "PlaylistTrack": ["PlaylistId", "TrackId"], "Track": ["TrackId", "Name", "AlbumId", "MediaTypeId", "GenreId", "Composer", "Milliseconds", "Bytes", "UnitPrice"]}, "answer": [["Battlestar Galactica: The Story So Far", 226], ["Battlestar Galactica, Season 3", 227], ["Heroes, Season 1", 228], ["Lost, Season 3", 229], ["Lost, Season 1", 230], ["Lost, Season 2", 231], ["The Office, Season 1", 249], ["The Office, Season 2", 250], ["The Office, Season 3", 251], ["Battlestar Galactica (Classic), Season 1", 253], ["Aquaman", 254], ["LOST, Season 4", 261]], "db_path": "data/spider/database/chinook_1/chinook_1.sqlite"}, "annotation": "t1 = pd.merge(album, track, left_on='albumid', right_on='albumid', how='left'); t1 = t1[t1['unitprice'] > 1]; answer = t1.groupby('albumid', as_index=False).first()[['title', 'albumid']]", "exec_result": "                                       title  albumid\n0     battlestar galactica: the story so far      226\n1             battlestar galactica, season 3      227\n2                           heroes, season 1      228\n3                             lost, season 3      229\n4                             lost, season 1      230\n5                             lost, season 2      231\n6                       the office, season 1      249\n7                       the office, season 2      250\n8                       the office, season 3      251\n9   battlestar galactica (classic), season 1      253\n10                                   aquaman      254\n11                            lost, season 4      261"}
{"metadata": {"db_id": "farm", "query": "SELECT T1.Status FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1", "query_toks": ["SELECT", "T1.Status", "FROM", "city", "AS", "T1", "JOIN", "farm_competition", "AS", "T2", "ON", "T1.City_ID", "=", "T2.Host_city_ID", "GROUP", "BY", "T2.Host_city_ID", "ORDER", "BY", "COUNT", "(", "*", ")", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "t1", ".", "status", "from", "city", "as", "t1", "join", "farm_competition", "as", "t2", "on", "t1", ".", "city_id", "=", "t2", ".", "host_city_id", "group", "by", "t2", ".", "host_city_id", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "Show the status of the city that has hosted the greatest number of competitions.", "question_toks": ["Show", "the", "status", "of", "the", "city", "that", "has", "hosted", "the", "greatest", "number", "of", "competitions", "."], "sql": {"from": {"table_units": [["table_unit", 0], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 1, false], null], [0, 20, false], null]]}, "select": [false, [[0, [0, [0, 3, false], null]]]], "where": [], "groupBy": [[0, 20, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["City_ID", "Official_Name", "Status", "Area_km_2", "Population", "Census_Ranking"], "farm": ["Farm_ID", "Year", "Total_Horses", "Working_Horses", "Total_Cattle", "Oxen", "Bulls", "Cows", "Pigs", "Sheep_and_Goats"], "farm_competition": ["Competition_ID", "Year", "Theme", "Host_city_ID", "Hosts"], "competition_record": ["Competition_ID", "Farm_ID", "Rank"]}, "answer": [["Village"]], "db_path": "data/spider/database/farm/farm.sqlite"}, "annotation": "t1 = pd.merge(city, farm_competition, left_on='city_id', right_on='host_city_id', how='left'); idx = t1.groupby('host_city_id').size().sort_values(ascending=False).index[0]; answer = city[city['city_id'] == idx]['status']", "exec_result": "4    village\nName: status, dtype: object"}
{"metadata": {"db_id": "activity_1", "query": "SELECT  T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "query_toks": ["SELECT", "T1.fname", ",", "T1.lname", "FROM", "Faculty", "AS", "T1", "JOIN", "Faculty_participates_in", "AS", "T2", "ON", "T1.facID", "=", "T2.facID", "GROUP", "BY", "T1.FacID", "ORDER", "BY", "count", "(", "*", ")", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "t1", ".", "fname", ",", "t1", ".", "lname", "from", "faculty", "as", "t1", "join", "faculty_participates_in", "as", "t2", "on", "t1", ".", "facid", "=", "t2", ".", "facid", "group", "by", "t1", ".", "facid", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "Find the first and last name of the faculty who is involved in the largest number of activities.", "question_toks": ["Find", "the", "first", "and", "last", "name", "of", "the", "faculty", "who", "is", "involved", "in", "the", "largest", "number", "of", "activities", "."], "sql": {"from": {"table_units": [["table_unit", 4], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 15, false], null], [0, 5, false], null]]}, "select": [false, [[0, [0, [0, 17, false], null]], [0, [0, [0, 16, false], null]]]], "where": [], "groupBy": [[0, 15, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Activity": ["actid", "activity_name"], "Participates_in": ["stuid", "actid"], "Faculty_Participates_in": ["FacID", "actid"], "Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"], "Faculty": ["FacID", "Lname", "Fname", "Rank", "Sex", "Phone", "Room", "Building"]}, "answer": [["Yair", "Amir"]], "db_path": "data/spider/database/activity_1/activity_1.sqlite"}, "annotation": "t1 = pd.merge(faculty, faculty_participates_in, left_on='facid', right_on='facid', how='left'); idx = t1.groupby('facid').size().sort_index(ascending=False).sort_values(ascending=False, kind='mergesort').index[0]; answer = faculty[faculty['facid'] == idx][['fname', 'lname']]", "exec_result": "   fname lname\n43  yair  amir"}
{"metadata": {"db_id": "inn_1", "query": "SELECT count(DISTINCT bedType) FROM Rooms;", "query_toks": ["SELECT", "count", "(", "DISTINCT", "bedType", ")", "FROM", "Rooms", ";"], "query_toks_no_value": ["select", "count", "(", "distinct", "bedtype", ")", "from", "rooms"], "question": "How many different types of beds are there?", "question_toks": ["How", "many", "different", "types", "of", "beds", "are", "there", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 4, true], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Rooms": ["RoomId", "roomName", "beds", "bedType", "maxOccupancy", "basePrice", "decor"], "Reservations": ["Code", "Room", "CheckIn", "CheckOut", "Rate", "LastName", "FirstName", "Adults", "Kids"]}, "answer": [[3]], "db_path": "data/spider/database/inn_1/inn_1.sqlite"}, "annotation": "answer = rooms['bedtype'].nunique()", "exec_result": "3"}
{"metadata": {"db_id": "soccer_2", "query": "SELECT * FROM College ORDER BY enr", "query_toks": ["SELECT", "*", "FROM", "College", "ORDER", "BY", "enr"], "query_toks_no_value": ["select", "*", "from", "college", "order", "by", "enr"], "question": "List all information about college sorted by enrollment number in the ascending order.", "question_toks": ["List", "all", "information", "about", "college", "sorted", "by", "enrollment", "number", "in", "the", "ascending", "order", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["asc", [[0, [0, 3, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"College": ["cName", "state", "enr"], "Player": ["pID", "pName", "yCard", "HS"], "Tryout": ["pID", "cName", "pPos", "decision"]}, "answer": [["ASU", "AZ", 12000], ["LSU", "LA", 18000], ["FSU", "FL", 19000], ["OU", "OK", 22000]], "db_path": "data/spider/database/soccer_2/soccer_2.sqlite"}, "annotation": "answer = college.sort_values(by='enr', ascending=True)", "exec_result": "  cname state    enr\n1   asu    az  12000\n0   lsu    la  18000\n3   fsu    fl  19000\n2    ou    ok  22000"}
{"metadata": {"db_id": "cinema", "query": "SELECT count(*) FROM film WHERE title LIKE \"%Dummy%\"", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "film", "WHERE", "title", "LIKE", "``", "%", "Dummy", "%", "''"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "film", "where", "title", "like", "value"], "question": "How many films have the word 'Dummy' in their titles?", "question_toks": ["How", "many", "films", "have", "the", "word", "'Dummy", "'", "in", "their", "titles", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 9, [0, [0, 4, false], null], "\"%Dummy%\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"film": ["Film_ID", "Rank_in_series", "Number_in_season", "Title", "Directed_by", "Original_air_date", "Production_code"], "cinema": ["Cinema_ID", "Name", "Openning_year", "Capacity", "Location"], "schedule": ["Cinema_ID", "Film_ID", "Date", "Show_times_per_day", "Price"]}, "answer": [[1]], "pandas_converted": "pd.Series(film[film['title'].str.contains('Dummy')].shape[0])", "db_path": "data/spider/database/cinema/cinema.sqlite"}, "annotation": "answer = film[film['title'].str.contains('Dummy', na=False)].shape[0]", "exec_result": "1"}
{"metadata": {"db_id": "baseball_1", "query": "SELECT state FROM park GROUP BY state HAVING count(*)  >  2;", "query_toks": ["SELECT", "state", "FROM", "park", "GROUP", "BY", "state", "HAVING", "count", "(", "*", ")", ">", "2", ";"], "query_toks_no_value": ["select", "state", "from", "park", "group", "by", "state", "having", "count", "(", "*", ")", ">", "value"], "question": "List the names of states that have more than 2 parks.", "question_toks": ["List", "the", "names", "of", "states", "that", "have", "more", "than", "2", "parks", "."], "sql": {"from": {"table_units": [["table_unit", 17]], "conds": []}, "select": [false, [[0, [0, [0, 210, false], null]]]], "where": [], "groupBy": [[0, 210, false]], "having": [[false, 3, [0, [3, 0, false], null], 2.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"all_star": ["player_id", "year", "game_num", "game_id", "team_id", "league_id", "gp", "starting_pos"], "appearances": ["year", "team_id", "league_id", "player_id", "g_all", "gs", "g_batting", "g_defense", "g_p", "g_c", "g_1b", "g_2b", "g_3b", "g_ss", "g_lf", "g_cf", "g_rf", "g_of", "g_dh", "g_ph", "g_pr"], "manager_award": ["player_id", "award_id", "year", "league_id", "tie", "notes"], "player_award": ["player_id", "award_id", "year", "league_id", "tie", "notes"], "manager_award_vote": ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"], "player_award_vote": ["award_id", "year", "league_id", "player_id", "points_won", "points_max", "votes_first"], "batting": ["player_id", "year", "stint", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"], "batting_postseason": ["year", "round", "player_id", "team_id", "league_id", "g", "ab", "r", "h", "double", "triple", "hr", "rbi", "sb", "cs", "bb", "so", "ibb", "hbp", "sh", "sf", "g_idp"], "player_college": ["player_id", "college_id", "year"], "fielding": ["player_id", "year", "stint", "team_id", "league_id", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "pb", "wp", "sb", "cs", "zr"], "fielding_outfield": ["player_id", "year", "stint", "glf", "gcf", "grf"], "fielding_postseason": ["player_id", "year", "team_id", "league_id", "round", "pos", "g", "gs", "inn_outs", "po", "a", "e", "dp", "tp", "pb", "sb", "cs"], "hall_of_fame": ["player_id", "yearid", "votedby", "ballots", "needed", "votes", "inducted", "category", "needed_note"], "home_game": ["year", "league_id", "team_id", "park_id", "span_first", "span_last", "games", "openings", "attendance"], "manager": ["player_id", "year", "team_id", "league_id", "inseason", "g", "w", "l", "rank", "plyr_mgr"], "manager_half": ["player_id", "year", "team_id", "league_id", "inseason", "half", "g", "w", "l", "rank"], "player": ["player_id", "birth_year", "birth_month", "birth_day", "birth_country", "birth_state", "birth_city", "death_year", "death_month", "death_day", "death_country", "death_state", "death_city", "name_first", "name_last", "name_given", "weight", "height", "bats", "throws", "debut", "final_game", "retro_id", "bbref_id"], "park": ["park_id", "park_name", "park_alias", "city", "state", "country"], "pitching": ["player_id", "year", "stint", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"], "pitching_postseason": ["player_id", "year", "round", "team_id", "league_id", "w", "l", "g", "gs", "cg", "sho", "sv", "ipouts", "h", "er", "hr", "bb", "so", "baopp", "era", "ibb", "wp", "hbp", "bk", "bfp", "gf", "r", "sh", "sf", "g_idp"], "salary": ["year", "team_id", "league_id", "player_id", "salary"], "college": ["college_id", "name_full", "city", "state", "country"], "postseason": ["year", "round", "team_id_winner", "league_id_winner", "team_id_loser", "league_id_loser", "wins", "losses", "ties"], "team": ["year", "league_id", "team_id", "franchise_id", "div_id", "rank", "g", "ghome", "w", "l", "div_win", "wc_win", "lg_win", "ws_win", "r", "ab", "h", "double", "triple", "hr", "bb", "so", "sb", "cs", "hbp", "sf", "ra", "er", "era", "cg", "sho", "sv", "ipouts", "ha", "hra", "bba", "soa", "e", "dp", "fp", "name", "park", "attendance", "bpf", "ppf", "team_id_br", "team_id_lahman45", "team_id_retro"], "team_franchise": ["franchise_id", "franchise_name", "active", "na_assoc"], "team_half": ["year", "league_id", "team_id", "half", "div_id", "div_win", "rank", "g", "w", "l"]}, "answer": [["CA"], ["CT"], ["DC"], ["FL"], ["IL"], ["IN"], ["KY"], ["MA"], ["MD"], ["MI"], ["MN"], ["MO"], ["NJ"], ["NY"], ["OH"], ["PA"], ["RI"], ["TX"], ["WA"], ["WI"]], "db_path": "data/spider/database/baseball_1/baseball_1.sqlite"}, "annotation": "answer = list(park.groupby('state').filter(lambda x: len(x) > 2).groupby('state').groups.keys())", "exec_result": "['ca', 'ct', 'dc', 'fl', 'il', 'in', 'ky', 'ma', 'md', 'mi', 'mn', 'mo', 'nj', 'ny', 'oh', 'pa', 'ri', 'tx', 'wa', 'wi']"}
{"metadata": {"db_id": "company_office", "query": "SELECT Headquarters FROM Companies GROUP BY Headquarters HAVING COUNT(*)  >  2", "query_toks": ["SELECT", "Headquarters", "FROM", "Companies", "GROUP", "BY", "Headquarters", "HAVING", "COUNT", "(", "*", ")", ">", "2"], "query_toks_no_value": ["select", "headquarters", "from", "companies", "group", "by", "headquarters", "having", "count", "(", "*", ")", ">", "value"], "question": "Show the headquarters shared by more than two companies.", "question_toks": ["Show", "the", "headquarters", "shared", "by", "more", "than", "two", "companies", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [], "groupBy": [[0, 9, false]], "having": [[false, 3, [0, [3, 0, false], null], 2.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"buildings": ["id", "name", "City", "Height", "Stories", "Status"], "Companies": ["id", "name", "Headquarters", "Industry", "Sales_billion", "Profits_billion", "Assets_billion", "Market_Value_billion"], "Office_locations": ["building_id", "company_id", "move_in_year"]}, "answer": [["China"], ["USA"]], "db_path": "data/spider/database/company_office/company_office.sqlite"}, "annotation": "answer = list(companies.groupby('headquarters').filter(lambda x: len(x) > 2).groupby('headquarters').groups.keys())", "exec_result": "['china', 'usa']"}
{"metadata": {"db_id": "party_host", "query": "SELECT count(*) FROM party", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "party"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "party"], "question": "Count the number of parties.", "question_toks": ["Count", "the", "number", "of", "parties", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"party": ["Party_ID", "Party_Theme", "Location", "First_year", "Last_year", "Number_of_hosts"], "host": ["Host_ID", "Name", "Nationality", "Age"], "party_host": ["Party_ID", "Host_ID", "Is_Main_in_Charge"]}, "answer": [[8]], "pandas_converted": "pd.Series(party.shape[0])", "db_path": "data/spider/database/party_host/party_host.sqlite"}, "annotation": "answer = party.shape[0]", "exec_result": "8"}
{"metadata": {"db_id": "candidate_poll", "query": "SELECT name FROM people WHERE height  >  200 OR height  <  190", "query_toks": ["SELECT", "name", "FROM", "people", "WHERE", "height", ">", "200", "OR", "height", "<", "190"], "query_toks_no_value": ["select", "name", "from", "people", "where", "height", ">", "value", "or", "height", "<", "value"], "question": "find the names of people who are taller than 200 or lower than 190.", "question_toks": ["find", "the", "names", "of", "people", "who", "are", "taller", "than", "200", "or", "lower", "than", "190", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 11, false], null]]]], "where": [[false, 3, [0, [0, 13, false], null], 200.0, null], "or", [false, 4, [0, [0, 13, false], null], 190.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"candidate": ["Candidate_ID", "People_ID", "Poll_Source", "Date", "Support_rate", "Consider_rate", "Oppose_rate", "Unsure_rate"], "people": ["People_ID", "Sex", "Name", "Date_of_Birth", "Height", "Weight"]}, "answer": [["Hubert Henno"], ["Laurent Capet"]], "pandas_converted": "people[(people['height'] > 200) | (people['height'] < 190)]['name']", "db_path": "data/spider/database/candidate_poll/candidate_poll.sqlite"}, "annotation": "answer = people[(people['height'] > 200) | (people['height'] < 190)]['name']", "exec_result": "0     hubert henno\n3    laurent capet\nName: name, dtype: object"}
{"metadata": {"db_id": "race_track", "query": "SELECT name ,  LOCATION FROM track", "query_toks": ["SELECT", "name", ",", "LOCATION", "FROM", "track"], "query_toks_no_value": ["select", "name", ",", "location", "from", "track"], "question": "Show the name and location for all tracks.", "question_toks": ["Show", "the", "name", "and", "location", "for", "all", "tracks", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 7, false], null]], [0, [0, [0, 8, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"race": ["Race_ID", "Name", "Class", "Date", "Track_ID"], "track": ["Track_ID", "Name", "Location", "Seating", "Year_Opened"]}, "answer": [["Auto Club Speedway", "Fontana, CA"], ["Chicagoland Speedway", "Joliet, IL"], ["Darlington Raceway", "Darlington, SC"], ["Daytona International Speedway", "Daytona Beach, FL"], ["Homestead-Miami Speedway", "Homestead, FL"], ["Kansas Speedway", "Kansas City, KS"], ["Martinsville Speedway", "Ridgeway, VA"], ["Michigan International Speedway", "Brooklyn, MI"], ["Phoenix International Raceway", "Avondale, AZ"]], "pandas_converted": "track[['name', 'location']]", "db_path": "data/spider/database/race_track/race_track.sqlite"}, "annotation": "answer = track[['name', 'location']]", "exec_result": "                              name           location\n0               auto club speedway        fontana, ca\n1             chicagoland speedway         joliet, il\n2               darlington raceway     darlington, sc\n3   daytona international speedway  daytona beach, fl\n4         homestead-miami speedway      homestead, fl\n5                  kansas speedway    kansas city, ks\n6            martinsville speedway       ridgeway, va\n7  michigan international speedway       brooklyn, mi\n8    phoenix international raceway       avondale, az"}
{"metadata": {"db_id": "student_assessment", "query": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "query_toks": ["SELECT", "student_id", "FROM", "student_course_registrations", "GROUP", "BY", "student_id", "ORDER", "BY", "count", "(", "*", ")", "LIMIT", "1"], "query_toks_no_value": ["select", "student_id", "from", "student_course_registrations", "group", "by", "student_id", "order", "by", "count", "(", "*", ")", "limit", "value"], "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "question_toks": ["What", "are", "the", "ids", "of", "the", "students", "who", "registered", "for", "some", "courses", "but", "had", "the", "least", "number", "of", "courses", "for", "all", "students", "?"], "sql": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[0, [0, [0, 27, false], null]]]], "where": [], "groupBy": [[0, 27, false]], "having": [], "orderBy": ["asc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "city", "zip_postcode", "state_province_county", "country"], "People": ["person_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "login_name", "password"], "Students": ["student_id", "student_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "People_Addresses": ["person_address_id", "person_id", "address_id", "date_from", "date_to"], "Student_Course_Registrations": ["student_id", "course_id", "registration_date"], "Student_Course_Attendance": ["student_id", "course_id", "date_of_attendance"], "Candidates": ["candidate_id", "candidate_details"], "Candidate_Assessments": ["candidate_id", "qualification", "assessment_date", "asessment_outcome_code"]}, "answer": [[111]], "db_path": "data/spider/database/student_assessment/student_assessment.sqlite"}, "annotation": "answer = student_course_registrations.groupby('student_id').size().sort_values(ascending=True, kind='mergesort').index[0]", "exec_result": "111"}
{"metadata": {"db_id": "music_4", "query": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "query_toks": ["SELECT", "Song", "FROM", "volume", "ORDER", "BY", "Weeks_on_Top", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "song", "from", "volume", "order", "by", "weeks_on_top", "desc", "limit", "value"], "question": "Return the song in the volume that has spent the most weeks on top?", "question_toks": ["Return", "the", "song", "in", "the", "volume", "that", "has", "spent", "the", "most", "weeks", "on", "top", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 10, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 9, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"artist": ["Artist_ID", "Artist", "Age", "Famous_Title", "Famous_Release_date"], "volume": ["Volume_ID", "Volume_Issue", "Issue_Date", "Weeks_on_Top", "Song", "Artist_ID"], "music_festival": ["ID", "Music_Festival", "Date_of_ceremony", "Category", "Volume", "Result"]}, "answer": [[" The Way"]], "db_path": "data/spider/database/music_4/music_4.sqlite"}, "annotation": "answer = volume.sort_values(by='weeks_on_top', ascending=False).iloc[0]['song']", "exec_result": " the way"}
{"metadata": {"db_id": "student_1", "query": "SELECT DISTINCT grade FROM list WHERE classroom  =  105", "query_toks": ["SELECT", "DISTINCT", "grade", "FROM", "list", "WHERE", "classroom", "=", "105"], "query_toks_no_value": ["select", "distinct", "grade", "from", "list", "where", "classroom", "=", "value"], "question": "Find the grade studying in room 105.", "question_toks": ["Find", "the", "grade", "studying", "in", "room", "105", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [true, [[0, [0, [0, 3, false], null]]]], "where": [[false, 2, [0, [0, 4, false], null], 105.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"list": ["LastName", "FirstName", "Grade", "Classroom"], "teachers": ["LastName", "FirstName", "Classroom"]}, "answer": [[0]], "pandas_converted": "list[list['classroom'] == 105]['grade'].drop_duplicates().reset_index(drop=True)", "db_path": "data/spider/database/student_1/student_1.sqlite"}, "annotation": "answer = list[list['classroom'] == 105]['grade'].unique()[0]", "exec_result": "0"}
{"metadata": {"db_id": "voter_2", "query": "SELECT count(*) FROM STUDENT", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "STUDENT"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "student"], "question": "Find the number of students in total.", "question_toks": ["Find", "the", "number", "of", "students", "in", "total", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"], "Voting_record": ["StuID", "Registration_Date", "Election_Cycle", "President_Vote", "Vice_President_Vote", "Secretary_Vote", "Treasurer_Vote", "Class_President_Vote", "Class_Senator_Vote"]}, "answer": [[34]], "db_path": "data/spider/database/voter_2/voter_2.sqlite"}, "annotation": "answer = student.shape[0]", "exec_result": "34"}
{"metadata": {"db_id": "dorm_1", "query": "SELECT count(DISTINCT major) ,  count(DISTINCT city_code) FROM student", "query_toks": ["SELECT", "count", "(", "DISTINCT", "major", ")", ",", "count", "(", "DISTINCT", "city_code", ")", "FROM", "student"], "query_toks_no_value": ["select", "count", "(", "distinct", "major", ")", ",", "count", "(", "distinct", "city_code", ")", "from", "student"], "question": "Find the numbers of different majors and cities.", "question_toks": ["Find", "the", "numbers", "of", "different", "majors", "and", "cities", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 6, true], null]], [3, [0, [0, 8, true], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"], "Dorm": ["dormid", "dorm_name", "student_capacity", "gender"], "Dorm_amenity": ["amenid", "amenity_name"], "Has_amenity": ["dormid", "amenid"], "Lives_in": ["stuid", "dormid", "room_number"]}, "answer": [[6, 19]], "db_path": "data/spider/database/dorm_1/dorm_1.sqlite"}, "annotation": "answer = [student['major'].nunique(), student['city_code'].nunique()]", "exec_result": "[6, 19]"}
{"metadata": {"db_id": "county_public_safety", "query": "SELECT T1.Name ,  T2.Name FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID", "query_toks": ["SELECT", "T1.Name", ",", "T2.Name", "FROM", "city", "AS", "T1", "JOIN", "county_public_safety", "AS", "T2", "ON", "T1.County_ID", "=", "T2.County_ID"], "query_toks_no_value": ["select", "t1", ".", "name", ",", "t2", ".", "name", "from", "city", "as", "t1", "join", "county_public_safety", "as", "t2", "on", "t1", ".", "county_id", "=", "t2", ".", "county_id"], "question": "Show names of cities and names of counties they are in.", "question_toks": ["Show", "names", "of", "cities", "and", "names", "of", "counties", "they", "are", "in", "."], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 11, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 12, false], null]], [0, [0, [0, 2, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"county_public_safety": ["County_ID", "Name", "Population", "Police_officers", "Residents_per_officer", "Case_burden", "Crime_rate", "Police_force", "Location"], "city": ["City_ID", "County_ID", "Name", "White", "Black", "Amerindian", "Asian", "Multiracial", "Hispanic"]}, "answer": [["Adjuntas", "Abbotsford"], ["Aguada", "Abbotsford"], ["Aguadilla", "Abbotsford"], ["Aguas Buenas", "Burnaby"], ["Aibonito", "Burnaby"], ["A\u00f1asco", "Campbell River"], ["Arecibo", "Campbell River"], ["Arroyo", "Campbell River"], ["Barceloneta", "Campbell River"], ["Barranquitas", "Campbell River"], ["Bayam\u00f3n", "Campbell River"], ["Cabo Rojo", "Castlegar"], ["Caguas", "Castlegar"], ["Camuy", "Central Saanich"], ["Can\u00f3vanas", "Central Saanich"], ["Carolina", "Chilliwack"], ["Cata\u00f1o", "Chilliwack"]], "db_path": "data/spider/database/county_public_safety/county_public_safety.sqlite"}, "annotation": "t1 = pd.merge(city, county_public_safety, left_on='county_id', right_on='county_id', how='left'); answer = [list(item) for item in zip(t1['name_x'], t1['name_y'])]", "exec_result": "[['adjuntas', 'abbotsford'], ['aguada', 'abbotsford'], ['aguadilla', 'abbotsford'], ['aguas buenas', 'burnaby'], ['aibonito', 'burnaby'], ['a\u00f1asco', 'campbell river'], ['arecibo', 'campbell river'], ['arroyo', 'campbell river'], ['barceloneta', 'campbell river'], ['barranquitas', 'campbell river'], ['bayam\u00f3n', 'campbell river'], ['cabo rojo', 'castlegar'], ['caguas', 'castlegar'], ['camuy', 'central saanich'], ['can\u00f3vanas', 'central saanich'], ['carolina', 'chilliwack'], ['cata\u00f1o', 'chilliwack']]"}
{"metadata": {"db_id": "allergy_1", "query": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "Student", "WHERE", "city_code", "=", "``", "HKG", "''", "OR", "city_code", "=", "``", "CHI", "''"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "student", "where", "city_code", "=", "value", "or", "city_code", "=", "value"], "question": "Give the number of students living in either HKG or CHI.", "question_toks": ["Give", "the", "number", "of", "students", "living", "in", "either", "HKG", "or", "CHI", "."], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 2, [0, [0, 12, false], null], "\"HKG\"", null], "or", [false, 2, [0, [0, 12, false], null], "\"CHI\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Allergy_Type": ["Allergy", "AllergyType"], "Has_Allergy": ["StuID", "Allergy"], "Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"]}, "answer": [[4]], "db_path": "data/spider/database/allergy_1/allergy_1.sqlite"}, "annotation": "answer = student[student['city_code'].isin(['hkg', 'chi'])].shape[0]", "exec_result": "4"}
{"metadata": {"db_id": "customers_and_products_contacts", "query": "SELECT customer_name ,  customer_phone ,  payment_method_code FROM customers ORDER BY customer_number DESC", "query_toks": ["SELECT", "customer_name", ",", "customer_phone", ",", "payment_method_code", "FROM", "customers", "ORDER", "BY", "customer_number", "DESC"], "query_toks_no_value": ["select", "customer_name", ",", "customer_phone", ",", "payment_method_code", "from", "customers", "order", "by", "customer_number", "desc"], "question": "Show the name, phone, and payment method code for all customers in descending order of customer number.", "question_toks": ["Show", "the", "name", ",", "phone", ",", "and", "payment", "method", "code", "for", "all", "customers", "in", "descending", "order", "of", "customer", "number", "."], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 14, false], null]], [0, [0, [0, 16, false], null]], [0, [0, [0, 12, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 13, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1_number_building", "city", "zip_postcode", "state_province_county", "country"], "Products": ["product_id", "product_type_code", "product_name", "product_price"], "Customers": ["customer_id", "payment_method_code", "customer_number", "customer_name", "customer_address", "customer_phone", "customer_email"], "Contacts": ["contact_id", "customer_id", "gender", "first_name", "last_name", "contact_phone"], "Customer_Address_History": ["customer_id", "address_id", "date_from", "date_to"], "Customer_Orders": ["order_id", "customer_id", "order_date", "order_status_code"], "Order_Items": ["order_item_id", "order_id", "product_id", "order_quantity"]}, "answer": [["Buford", "(192)144-4687", "Credit Card"], ["Cheyenne", "009-136-4509x19635", "Direct Debit"], ["Cleo", "1-202-928-5395", "Credit Card"], ["Raymond", "1-513-427-0125", "Direct Debit"], ["Orion", "479-171-6355x66065", "Direct Debit"], ["Madaline", "097-514-4641", "Credit Card"], ["Brenna", "1-271-345-4681x1131", "Credit Card"], ["Sterling", "896.685.8228x2786", "Credit Card"], ["Lela", "838.718.8618x23239", "Credit Card"], ["Ottilie", "393-750-2077x72779", "Direct Debit"], ["Caterina", "387.053.1225", "Direct Debit"], ["Kayley", "+87(9)5279161988", "Credit Card"], ["Melissa", "529.148.1926", "Direct Debit"], ["Cecelia", "672-559-0630x7875", "Direct Debit"], ["Shany", "936.929.9929", "Direct Debit"]], "db_path": "data/spider/database/customers_and_products_contacts/customers_and_products_contacts.sqlite"}, "annotation": "t1 = customers.sort_values(by='customer_number', ascending=False); answer = [list(item) for item in zip(t1['customer_name'], t1['customer_phone'], t1['payment_method_code'])]", "exec_result": "[['buford', '(192)144-4687', 'credit card'], ['cheyenne', '009-136-4509x19635', 'direct debit'], ['cleo', '1-202-928-5395', 'credit card'], ['raymond', '1-513-427-0125', 'direct debit'], ['orion', '479-171-6355x66065', 'direct debit'], ['madaline', '097-514-4641', 'credit card'], ['brenna', '1-271-345-4681x1131', 'credit card'], ['sterling', '896.685.8228x2786', 'credit card'], ['lela', '838.718.8618x23239', 'credit card'], ['ottilie', '393-750-2077x72779', 'direct debit'], ['caterina', '387.053.1225', 'direct debit'], ['kayley', '+87(9)5279161988', 'credit card'], ['melissa', '529.148.1926', 'direct debit'], ['cecelia', '672-559-0630x7875', 'direct debit'], ['shany', '936.929.9929', 'direct debit']]"}
{"metadata": {"db_id": "student_1", "query": "SELECT DISTINCT firstname FROM list WHERE classroom  =  107", "query_toks": ["SELECT", "DISTINCT", "firstname", "FROM", "list", "WHERE", "classroom", "=", "107"], "query_toks_no_value": ["select", "distinct", "firstname", "from", "list", "where", "classroom", "=", "value"], "question": "List the first names of all the students in room 107.", "question_toks": ["List", "the", "first", "names", "of", "all", "the", "students", "in", "room", "107", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [true, [[0, [0, [0, 2, false], null]]]], "where": [[false, 2, [0, [0, 4, false], null], 107.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"list": ["LastName", "FirstName", "Grade", "Classroom"], "teachers": ["LastName", "FirstName", "Classroom"]}, "answer": [[" SHERWOOD"], [" ROBBY"], [" CRYSTA"], [" VERTIE"], [" CHRISSY"], [" JORDON"]], "pandas_converted": "list[list['classroom'] == 107]['firstname'].drop_duplicates().reset_index(drop=True)", "db_path": "data/spider/database/student_1/student_1.sqlite"}, "annotation": "answer = list[list['classroom'] == 107]['firstname'].unique()", "exec_result": "[' sherwood' ' robby' ' crysta' ' vertie' ' chrissy' ' jordon']"}
{"metadata": {"db_id": "city_record", "query": "SELECT gdp FROM city ORDER BY Regional_Population DESC LIMIT 1", "query_toks": ["SELECT", "gdp", "FROM", "city", "ORDER", "BY", "Regional_Population", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "gdp", "from", "city", "order", "by", "regional_population", "desc", "limit", "value"], "question": "what is the GDP of the city with the largest population.", "question_toks": ["what", "is", "the", "GDP", "of", "the", "city", "with", "the", "largest", "population", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 6, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 5, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["City_ID", "City", "Hanzi", "Hanyu_Pinyin", "Regional_Population", "GDP"], "match": ["Match_ID", "Date", "Venue", "Score", "Result", "Competition"], "temperature": ["City_ID", "Jan", "Feb", "Mar", "Apr", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], "hosting_city": ["Year", "Match_ID", "Host_City"]}, "answer": [[1919.57]], "db_path": "data/spider/database/city_record/city_record.sqlite"}, "annotation": "answer = city.sort_values(by='regional_population', ascending=False).iloc[0]['gdp']", "exec_result": "1919.57"}
{"metadata": {"db_id": "tracking_orders", "query": "SELECT order_item_id FROM order_items WHERE product_id = 11", "query_toks": ["SELECT", "order_item_id", "FROM", "order_items", "WHERE", "product_id", "=", "11"], "query_toks_no_value": ["select", "order_item_id", "from", "order_items", "where", "product_id", "=", "value"], "question": "Find the ids of all the order items whose product id is 11.", "question_toks": ["Find", "the", "ids", "of", "all", "the", "order", "items", "whose", "product", "id", "is", "11", "."], "sql": {"from": {"table_units": [["table_unit", 4]], "conds": []}, "select": [false, [[0, [0, [0, 15, false], null]]]], "where": [[false, 2, [0, [0, 16, false], null], 11.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Customers": ["customer_id", "customer_name", "customer_details"], "Invoices": ["invoice_number", "invoice_date", "invoice_details"], "Orders": ["order_id", "customer_id", "order_status", "date_order_placed", "order_details"], "Products": ["product_id", "product_name", "product_details"], "Order_Items": ["order_item_id", "product_id", "order_id", "order_item_status", "order_item_details"], "Shipments": ["shipment_id", "order_id", "invoice_number", "shipment_tracking_number", "shipment_date", "other_shipment_details"], "Shipment_Items": ["shipment_id", "order_item_id"]}, "answer": [[5], [9]], "db_path": "data/spider/database/tracking_orders/tracking_orders.sqlite"}, "annotation": "answer = order_items[order_items['product_id'] == 11]['order_item_id']", "exec_result": "4    5\n8    9\nName: order_item_id, dtype: int64"}
{"metadata": {"db_id": "hospital_1", "query": "SELECT DISTINCT T1.name FROM nurse AS T1 JOIN on_call AS T2 ON T1.EmployeeID  =  T2.nurse", "query_toks": ["SELECT", "DISTINCT", "T1.name", "FROM", "nurse", "AS", "T1", "JOIN", "on_call", "AS", "T2", "ON", "T1.EmployeeID", "=", "T2.nurse"], "query_toks_no_value": ["select", "distinct", "t1", ".", "name", "from", "nurse", "as", "t1", "join", "on_call", "as", "t2", "on", "t1", ".", "employeeid", "=", "t2", ".", "nurse"], "question": "What are the distinct names of nurses on call?", "question_toks": ["What", "are", "the", "distinct", "names", "of", "nurses", "on", "call", "?"], "sql": {"from": {"table_units": [["table_unit", 6], ["table_unit", 12]], "conds": [[false, 2, [0, [0, 24, false], null], [0, 53, false], null]]}, "select": [true, [[0, [0, [0, 25, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Physician": ["EmployeeID", "Name", "Position", "SSN"], "Department": ["DepartmentID", "Name", "Head"], "Affiliated_With": ["Physician", "Department", "PrimaryAffiliation"], "Procedures": ["Code", "Name", "Cost"], "Trained_In": ["Physician", "Treatment", "CertificationDate", "CertificationExpires"], "Patient": ["SSN", "Name", "Address", "Phone", "InsuranceID", "PCP"], "Nurse": ["EmployeeID", "Name", "Position", "Registered", "SSN"], "Appointment": ["AppointmentID", "Patient", "PrepNurse", "Physician", "Start", "End", "ExaminationRoom"], "Medication": ["Code", "Name", "Brand", "Description"], "Prescribes": ["Physician", "Patient", "Medication", "Date", "Appointment", "Dose"], "Block": ["BlockFloor", "BlockCode"], "Room": ["RoomNumber", "RoomType", "BlockFloor", "BlockCode", "Unavailable"], "On_Call": ["Nurse", "BlockFloor", "BlockCode", "OnCallStart", "OnCallEnd"], "Stay": ["StayID", "Patient", "Room", "StayStart", "StayEnd"], "Undergoes": ["Patient", "Procedures", "Stay", "DateUndergoes", "Physician", "AssistingNurse"]}, "answer": [["Carla Espinosa"], ["Laverne Roberts"], ["Paul Flowers"]], "db_path": "data/spider/database/hospital_1/hospital_1.sqlite"}, "annotation": "answer = pd.merge(nurse, on_call, left_on='employeeid', right_on='nurse', how='left')['name'].unique()", "exec_result": "['carla espinosa' 'laverne roberts' 'paul flowers']"}
{"metadata": {"db_id": "store_1", "query": "SELECT billing_country ,  COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;", "query_toks": ["SELECT", "billing_country", ",", "COUNT", "(", "*", ")", "FROM", "invoices", "GROUP", "BY", "billing_country", "ORDER", "BY", "count", "(", "*", ")", "DESC", "LIMIT", "5", ";"], "query_toks_no_value": ["select", "billing_country", ",", "count", "(", "*", ")", "from", "invoices", "group", "by", "billing_country", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "What are the top 5 countries by number of invoices and how many do they have?", "question_toks": ["What", "are", "the", "top", "5", "countries", "by", "number", "of", "invoices", "and", "how", "many", "do", "they", "have", "?"], "sql": {"from": {"table_units": [["table_unit", 6]], "conds": []}, "select": [false, [[0, [0, [0, 44, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 44, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 5, "intersect": null, "union": null, "except": null}, "db_table_headers": {"artists": ["id", "name"], "sqlite_sequence": ["name", "seq"], "albums": ["id", "title", "artist_id"], "employees": ["id", "last_name", "first_name", "title", "reports_to", "birth_date", "hire_date", "address", "city", "state", "country", "postal_code", "phone", "fax", "email"], "customers": ["id", "first_name", "last_name", "company", "address", "city", "state", "country", "postal_code", "phone", "fax", "email", "support_rep_id"], "genres": ["id", "name"], "invoices": ["id", "customer_id", "invoice_date", "billing_address", "billing_city", "billing_state", "billing_country", "billing_postal_code", "total"], "media_types": ["id", "name"], "tracks": ["id", "name", "album_id", "media_type_id", "genre_id", "composer", "milliseconds", "bytes", "unit_price"], "invoice_lines": ["id", "invoice_id", "track_id", "unit_price", "quantity"], "playlists": ["id", "name"], "playlist_tracks": ["playlist_id", "track_id"]}, "answer": [["USA", 91], ["Canada", 56], ["France", 35], ["Brazil", 35], ["Germany", 28]], "db_path": "data/spider/database/store_1/store_1.sqlite"}, "annotation": "t1 = invoices.groupby('billing_country').size().sort_index(ascending=False).sort_values(ascending=False, kind='mergesort').iloc[:5]; answer = [list(item) for item in zip(t1.index, t1)]", "exec_result": "[['usa', 91], ['canada', 56], ['france', 35], ['brazil', 35], ['germany', 28]]"}
{"metadata": {"db_id": "products_gen_characteristics", "query": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "Ref_colors", "WHERE", "color_code", "NOT", "IN", "(", "SELECT", "color_code", "FROM", "products", ")"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "ref_colors", "where", "color_code", "not", "in", "(", "select", "color_code", "from", "products", ")"], "question": "How many colors are never used by any product?", "question_toks": ["How", "many", "colors", "are", "never", "used", "by", "any", "product", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[true, 8, [0, [0, 3, false], null], {"from": {"table_units": [["table_unit", 4]], "conds": []}, "select": [false, [[0, [0, [0, 14, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Characteristic_Types": ["characteristic_type_code", "characteristic_type_description"], "Ref_Colors": ["color_code", "color_description"], "Ref_Product_Categories": ["product_category_code", "product_category_description", "unit_of_measure"], "Characteristics": ["characteristic_id", "characteristic_type_code", "characteristic_data_type", "characteristic_name", "other_characteristic_details"], "Products": ["product_id", "color_code", "product_category_code", "product_name", "typical_buying_price", "typical_selling_price", "product_description", "other_product_details"], "Product_Characteristics": ["product_id", "characteristic_id", "product_characteristic_value"]}, "answer": [[2]], "db_path": "data/spider/database/products_gen_characteristics/products_gen_characteristics.sqlite"}, "annotation": "answer = ref_colors[~ref_colors['color_code'].isin(products['color_code'])].shape[0]", "exec_result": "2"}
{"metadata": {"db_id": "product_catalog", "query": "SELECT catalog_entry_name FROM catalog_contents WHERE product_stock_number LIKE \"2%\"", "query_toks": ["SELECT", "catalog_entry_name", "FROM", "catalog_contents", "WHERE", "product_stock_number", "LIKE", "``", "2", "%", "''"], "query_toks_no_value": ["select", "catalog_entry_name", "from", "catalog_contents", "where", "product_stock_number", "like", "value"], "question": "Which catalog contents have a product stock number that starts from \"2\"? Show the catalog entry names.", "question_toks": ["Which", "catalog", "contents", "have", "a", "product", "stock", "number", "that", "starts", "from", "``", "2", "''", "?", "Show", "the", "catalog", "entry", "names", "."], "sql": {"from": {"table_units": [["table_unit", 3]], "conds": []}, "select": [false, [[0, [0, [0, 17, false], null]]]], "where": [[false, 9, [0, [0, 18, false], null], "\"2%\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Attribute_Definitions": ["attribute_id", "attribute_name", "attribute_data_type"], "Catalogs": ["catalog_id", "catalog_name", "catalog_publisher", "date_of_publication", "date_of_latest_revision"], "Catalog_Structure": ["catalog_level_number", "catalog_id", "catalog_level_name"], "Catalog_Contents": ["catalog_entry_id", "catalog_level_number", "parent_entry_id", "previous_entry_id", "next_entry_id", "catalog_entry_name", "product_stock_number", "price_in_dollars", "price_in_euros", "price_in_pounds", "capacity", "length", "height", "width"], "Catalog_Contents_Additional_Attributes": ["catalog_entry_id", "catalog_level_number", "attribute_id", "attribute_value"]}, "answer": [["Sprite Lemo"], ["Dr Pepper"]], "db_path": "data/spider/database/product_catalog/product_catalog.sqlite"}, "annotation": "answer = catalog_contents[catalog_contents['product_stock_number'].str.startswith('2', na=False)]['catalog_entry_name']", "exec_result": "8    sprite lemo\n9      dr pepper\nName: catalog_entry_name, dtype: object"}
{"metadata": {"db_id": "products_for_hire", "query": "SELECT T2.product_name FROM view_product_availability AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.available_yn  =  1", "query_toks": ["SELECT", "T2.product_name", "FROM", "view_product_availability", "AS", "T1", "JOIN", "products_for_hire", "AS", "T2", "ON", "T1.product_id", "=", "T2.product_id", "WHERE", "T1.available_yn", "=", "1"], "query_toks_no_value": ["select", "t2", ".", "product_name", "from", "view_product_availability", "as", "t1", "join", "products_for_hire", "as", "t2", "on", "t1", ".", "product_id", "=", "t2", ".", "product_id", "where", "t1", ".", "available_yn", "=", "value"], "question": "What are the names of products whose availability equals to 1?", "question_toks": ["What", "are", "the", "names", "of", "products", "whose", "availability", "equals", "to", "1", "?"], "sql": {"from": {"table_units": [["table_unit", 6], ["table_unit", 3]], "conds": [[false, 2, [0, [0, 42, false], null], [0, 23, false], null]]}, "select": [false, [[0, [0, [0, 26, false], null]]]], "where": [[false, 2, [0, [0, 45, false], null], 1.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Discount_Coupons": ["coupon_id", "date_issued", "coupon_amount"], "Customers": ["customer_id", "coupon_id", "good_or_bad_customer", "first_name", "last_name", "gender_mf", "date_became_customer", "date_last_hire"], "Bookings": ["booking_id", "customer_id", "booking_status_code", "returned_damaged_yn", "booking_start_date", "booking_end_date", "count_hired", "amount_payable", "amount_of_discount", "amount_outstanding", "amount_of_refund"], "Products_for_Hire": ["product_id", "product_type_code", "daily_hire_cost", "product_name", "product_description"], "Payments": ["payment_id", "booking_id", "customer_id", "payment_type_code", "amount_paid_in_full_yn", "payment_date", "amount_due", "amount_paid"], "Products_Booked": ["booking_id", "product_id", "returned_yn", "returned_late_yn", "booked_count", "booked_amount"], "View_Product_Availability": ["product_id", "booking_id", "status_date", "available_yn"]}, "answer": [["Book collection C"], ["Book collection A"], ["DVD collection B"]], "db_path": "data/spider/database/products_for_hire/products_for_hire.sqlite"}, "annotation": "t1 = pd.merge(view_product_availability, products_for_hire, left_on='product_id', right_on='product_id', how='left'); answer = t1[t1['available_yn'] == '1']['product_name']", "exec_result": "0    book collection c\n2    book collection a\n3     dvd collection b\nName: product_name, dtype: object"}
{"metadata": {"db_id": "browser_web", "query": "SELECT name FROM web_client_accelerator WHERE name LIKE \"%Opera%\"", "query_toks": ["SELECT", "name", "FROM", "web_client_accelerator", "WHERE", "name", "LIKE", "``", "%", "Opera", "%", "''"], "query_toks_no_value": ["select", "name", "from", "web_client_accelerator", "where", "name", "like", "value"], "question": "Which accelerator name contains substring \"Opera\"?", "question_toks": ["Which", "accelerator", "name", "contains", "substring", "``", "Opera", "''", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 2, false], null]]]], "where": [[false, 9, [0, [0, 2, false], null], "\"%Opera%\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Web_client_accelerator": ["id", "name", "Operating_system", "Client", "Connection"], "browser": ["id", "name", "market_share"], "accelerator_compatible_browser": ["accelerator_id", "browser_id", "compatible_since_year"]}, "answer": [["Opera Turbo"]], "db_path": "data/spider/database/browser_web/browser_web.sqlite"}, "annotation": "answer = web_client_accelerator[web_client_accelerator['name'].str.contains('Opera', na=False)]['name']", "exec_result": "10    opera turbo\nName: name, dtype: object"}
{"metadata": {"db_id": "storm_record", "query": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T3.number_deaths  >=  10", "query_toks": ["SELECT", "T2.region_name", "FROM", "affected_region", "AS", "T1", "JOIN", "region", "AS", "T2", "ON", "T1.region_id", "=", "T2.region_id", "JOIN", "storm", "AS", "T3", "ON", "T1.storm_id", "=", "T3.storm_id", "WHERE", "T3.number_deaths", ">", "=", "10"], "query_toks_no_value": ["select", "t2", ".", "region_name", "from", "affected_region", "as", "t1", "join", "region", "as", "t2", "on", "t1", ".", "region_id", "=", "t2", ".", "region_id", "join", "storm", "as", "t3", "on", "t1", ".", "storm_id", "=", "t3", ".", "storm_id", "where", "t3", ".", "number_deaths", ">", "=", "value"], "question": "Return the names of the regions affected by storms that had a death count of at least 10.", "question_toks": ["Return", "the", "names", "of", "the", "regions", "affected", "by", "storms", "that", "had", "a", "death", "count", "of", "at", "least", "10", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 1], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 10, false], null], [0, 7, false], null], "and", [false, 2, [0, [0, 11, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [[false, 5, [0, [0, 6, false], null], 10.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"storm": ["Storm_ID", "Name", "Dates_active", "Max_speed", "Damage_millions_USD", "Number_Deaths"], "region": ["Region_id", "Region_code", "Region_name"], "affected_region": ["Region_id", "Storm_ID", "Number_city_affected"]}, "answer": [["Algeria"]], "db_path": "data/spider/database/storm_record/storm_record.sqlite"}, "annotation": "t1 = pd.merge(affected_region, region, left_on='region_id', right_on='region_id', how='left'); t2 = pd.merge(t1, storm, left_on='storm_id', right_on='storm_id', how='left'); answer = t2[t2['number_deaths'] >= 30]['region_name']", "exec_result": "2    algeria\nName: region_name, dtype: object"}
{"metadata": {"db_id": "ship_1", "query": "SELECT count(DISTINCT rank) FROM captain", "query_toks": ["SELECT", "count", "(", "DISTINCT", "rank", ")", "FROM", "captain"], "query_toks_no_value": ["select", "count", "(", "distinct", "rank", ")", "from", "captain"], "question": "Count the number of different ranks of captain.", "question_toks": ["Count", "the", "number", "of", "different", "ranks", "of", "captain", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 6, true], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"captain": ["Captain_ID", "Name", "Ship_ID", "age", "Class", "Rank"], "Ship": ["Ship_ID", "Name", "Type", "Built_Year", "Class", "Flag"]}, "answer": [[3]], "pandas_converted": "pd.Series(captain['rank'].drop_duplicates().size)", "db_path": "data/spider/database/ship_1/ship_1.sqlite"}, "annotation": "answer = captain['rank'].nunique()", "exec_result": "3"}
{"metadata": {"db_id": "cre_Theme_park", "query": "SELECT hotel_id ,  star_rating_code FROM HOTELS ORDER BY price_range ASC", "query_toks": ["SELECT", "hotel_id", ",", "star_rating_code", "FROM", "HOTELS", "ORDER", "BY", "price_range", "ASC"], "query_toks_no_value": ["select", "hotel_id", ",", "star_rating_code", "from", "hotels", "order", "by", "price_range", "asc"], "question": "Find the id and star rating of each hotel and sort them in increasing order of price.", "question_toks": ["Find", "the", "id", "and", "star", "rating", "of", "each", "hotel", "and", "sort", "them", "in", "increasing", "order", "of", "price", "."], "sql": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[0, [0, [0, 13, false], null]], [0, [0, [0, 14, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["asc", [[0, [0, 16, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Hotel_Star_Ratings": ["star_rating_code", "star_rating_description"], "Locations": ["Location_ID", "Location_Name", "Address", "Other_Details"], "Ref_Attraction_Types": ["Attraction_Type_Code", "Attraction_Type_Description"], "Visitors": ["Tourist_ID", "Tourist_Details"], "Features": ["Feature_ID", "Feature_Details"], "Hotels": ["hotel_id", "star_rating_code", "pets_allowed_yn", "price_range", "other_hotel_details"], "Tourist_Attractions": ["Tourist_Attraction_ID", "Attraction_Type_Code", "Location_ID", "How_to_Get_There", "Name", "Description", "Opening_Hours", "Other_Details"], "Street_Markets": ["Market_ID", "Market_Details"], "Shops": ["Shop_ID", "Shop_Details"], "Museums": ["Museum_ID", "Museum_Details"], "Royal_Family": ["Royal_Family_ID", "Royal_Family_Details"], "Theme_Parks": ["Theme_Park_ID", "Theme_Park_Details"], "Visits": ["Visit_ID", "Tourist_Attraction_ID", "Tourist_ID", "Visit_Date", "Visit_Details"], "Photos": ["Photo_ID", "Tourist_Attraction_ID", "Name", "Description", "Filename", "Other_Details"], "Staff": ["Staff_ID", "Tourist_Attraction_ID", "Name", "Other_Details"], "Tourist_Attraction_Features": ["Tourist_Attraction_ID", "Feature_ID"]}, "answer": [[431, "2"], [426, "5"], [473, "1"], [555, "5"], [420, "5"], [172, "5"], [264, "1"], [442, "2"], [514, "5"], [123, "5"], [421, "3"], [379, "4"], [373, "5"], [314, "5"], [144, "4"], [222, "5"], [239, "3"], [331, "1"], [350, "1"], [376, "2"]], "db_path": "data/spider/database/cre_Theme_park/cre_Theme_park.sqlite"}, "annotation": "answer = hotels.mask(hotels == '').sort_values(by='price_range', ascending=True, kind='mergesort')[['hotel_id', 'star_rating_code']]", "exec_result": "    hotel_id star_rating_code\n15       431                2\n14       426                5\n17       473                1\n19       555                5\n12       420                5\n2        172                5\n5        264                1\n16       442                2\n18       514                5\n0        123                5\n13       421                3\n11       379                4\n9        373                5\n6        314                5\n1        144                4\n3        222                5\n4        239                3\n7        331                1\n8        350                1\n10       376                2"}
{"metadata": {"db_id": "customers_and_addresses", "query": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Tillman Ernser\"", "query_toks": ["SELECT", "DISTINCT", "channel_code", "FROM", "customers", "AS", "t1", "JOIN", "customer_contact_channels", "AS", "t2", "ON", "t1.customer_id", "=", "t2.customer_id", "WHERE", "t1.customer_name", "=", "``", "Tillman", "Ernser", "''"], "query_toks_no_value": ["select", "distinct", "channel_code", "from", "customers", "as", "t1", "join", "customer_contact_channels", "as", "t2", "on", "t1", ".", "customer_id", "=", "t2", ".", "customer_id", "where", "t1", ".", "customer_name", "=", "value"], "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "question_toks": ["Find", "the", "contact", "channel", "code", "that", "was", "used", "by", "the", "customer", "named", "``", "Tillman", "Ernser", "''", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 4]], "conds": [[false, 2, [0, [0, 10, false], null], [0, 20, false], null]]}, "select": [true, [[0, [0, [0, 21, false], null]]]], "where": [[false, 2, [0, [0, 12, false], null], "\"Tillman Ernser\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "address_content", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Products": ["product_id", "product_details"], "Customers": ["customer_id", "payment_method", "customer_name", "date_became_customer", "other_customer_details"], "Customer_Addresses": ["customer_id", "address_id", "date_address_from", "address_type", "date_address_to"], "Customer_Contact_Channels": ["customer_id", "channel_code", "active_from_date", "active_to_date", "contact_number"], "Customer_Orders": ["order_id", "customer_id", "order_status", "order_date", "order_details"], "Order_Items": ["order_id", "product_id", "order_quantity"]}, "answer": [["Email"], ["Cell"], ["Handheld"]], "db_path": "data/spider/database/customers_and_addresses/customers_and_addresses.sqlite"}, "annotation": "t1 = pd.merge(customers, customer_contact_channels, left_on='customer_id', right_on='customer_id', how='left'); answer = t1[t1['customer_name'] == 'Tillman Ernser']['channel_code'].unique()", "exec_result": "['email' 'cell' 'handheld']"}
{"metadata": {"db_id": "party_host", "query": "SELECT avg(Number_of_hosts) FROM party", "query_toks": ["SELECT", "avg", "(", "Number_of_hosts", ")", "FROM", "party"], "query_toks_no_value": ["select", "avg", "(", "number_of_hosts", ")", "from", "party"], "question": "What is the average number of hosts for parties?", "question_toks": ["What", "is", "the", "average", "number", "of", "hosts", "for", "parties", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[5, [0, [0, 6, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"party": ["Party_ID", "Party_Theme", "Location", "First_year", "Last_year", "Number_of_hosts"], "host": ["Host_ID", "Name", "Nationality", "Age"], "party_host": ["Party_ID", "Host_ID", "Is_Main_in_Charge"]}, "answer": [[12.25]], "pandas_converted": "pd.Series(party['number_of_hosts'].mean())", "db_path": "data/spider/database/party_host/party_host.sqlite"}, "annotation": "answer = party['number_of_hosts'].mean()", "exec_result": "12.25"}
{"metadata": {"db_id": "college_2", "query": "SELECT T1.name FROM instructor AS T1 JOIN advisor AS T2 ON T1.id  =  T2.i_id GROUP BY T2.i_id HAVING count(*)  >  1", "query_toks": ["SELECT", "T1.name", "FROM", "instructor", "AS", "T1", "JOIN", "advisor", "AS", "T2", "ON", "T1.id", "=", "T2.i_id", "GROUP", "BY", "T2.i_id", "HAVING", "count", "(", "*", ")", ">", "1"], "query_toks_no_value": ["select", "t1", ".", "name", "from", "instructor", "as", "t1", "join", "advisor", "as", "t2", "on", "t1", ".", "id", "=", "t2", ".", "i_id", "group", "by", "t2", ".", "i_id", "having", "count", "(", "*", ")", ">", "value"], "question": "What are the names of instructors who advise more than one student?", "question_toks": ["What", "are", "the", "names", "of", "instructors", "who", "advise", "more", "than", "one", "student", "?"], "sql": {"from": {"table_units": [["table_unit", 3], ["table_unit", 8]], "conds": [[false, 2, [0, [0, 11, false], null], [0, 38, false], null]]}, "select": [false, [[0, [0, [0, 12, false], null]]]], "where": [], "groupBy": [[0, 38, false]], "having": [[false, 3, [0, [3, 0, false], null], 1.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"classroom": ["building", "room_number", "capacity"], "department": ["dept_name", "building", "budget"], "course": ["course_id", "title", "dept_name", "credits"], "instructor": ["ID", "name", "dept_name", "salary"], "section": ["course_id", "sec_id", "semester", "year", "building", "room_number", "time_slot_id"], "teaches": ["ID", "course_id", "sec_id", "semester", "year"], "student": ["ID", "name", "dept_name", "tot_cred"], "takes": ["ID", "course_id", "sec_id", "semester", "year", "grade"], "advisor": ["s_ID", "i_ID"], "time_slot": ["time_slot_id", "day", "start_hr", "start_min", "end_hr", "end_min"], "prereq": ["course_id", "prereq_id"]}, "answer": [["Lembr"], ["Bawa"], ["Yazdi"], ["Wieland"], ["DAgostino"], ["Liley"], ["Kean"], ["Atanassov"], ["Moreira"], ["Gustafsson"], ["Bourrier"], ["Bondi"], ["Soisalon-Soininen"], ["Morris"], ["Arias"], ["Murata"], ["Tung"], ["Luo"], ["Vicentino"], ["Romero"], ["Lent"], ["Sarkar"], ["Shuming"], ["Konstantinides"], ["Bancilhon"], ["Hau"], ["Dusserre"], ["Desyl"], ["Jaekel"], ["McKinnon"], ["Gutierrez"], ["Mingoz"], ["Pimenta"], ["Yin"], ["Sullivan"], ["Voronina"], ["Kenje"], ["Mahmoud"], ["Pingr"], ["Ullman "], ["Levine"], ["Queiroz"], ["Valtchev"], ["Bietzk"], ["Choll"], ["Arinb"], ["Sakurai"], ["Mird"], ["Bertolino"], ["Dale"]], "db_path": "data/spider/database/college_2/college_2.sqlite"}, "annotation": "answer = pd.merge(instructor, advisor, left_on='id', right_on='i_id', how='left').groupby('i_id').filter(lambda x: len(x) > 1)['name'].unique()", "exec_result": "['mckinnon' 'pingr' 'mird' 'luo' 'murata' 'konstantinides' 'levine'\n 'shuming' 'queiroz' 'sullivan' 'bertolino' 'hau' 'voronina'\n 'soisalon-soininen' 'moreira' 'arias' 'mingoz' 'yazdi' 'lembr' 'choll'\n 'valtchev' 'arinb' 'bawa' 'kenje' 'vicentino' 'dusserre' 'jaekel' 'desyl'\n 'dagostino' 'sarkar' 'ullman ' 'bancilhon' 'liley' 'morris' 'yin'\n 'gustafsson' 'bondi' 'lent' 'pimenta' 'bourrier' 'gutierrez' 'sakurai'\n 'romero' 'mahmoud' 'kean' 'bietzk' 'atanassov' 'tung' 'wieland' 'dale']"}
{"metadata": {"db_id": "party_host", "query": "SELECT T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID WHERE T3.Number_of_hosts  >  20", "query_toks": ["SELECT", "T2.Name", "FROM", "party_host", "AS", "T1", "JOIN", "HOST", "AS", "T2", "ON", "T1.Host_ID", "=", "T2.Host_ID", "JOIN", "party", "AS", "T3", "ON", "T1.Party_ID", "=", "T3.Party_ID", "WHERE", "T3.Number_of_hosts", ">", "20"], "query_toks_no_value": ["select", "t2", ".", "name", "from", "party_host", "as", "t1", "join", "host", "as", "t2", "on", "t1", ".", "host_id", "=", "t2", ".", "host_id", "join", "party", "as", "t3", "on", "t1", ".", "party_id", "=", "t3", ".", "party_id", "where", "t3", ".", "number_of_hosts", ">", "value"], "question": "Which parties have more than 20 hosts? Give me the host names for these parties.", "question_toks": ["Which", "parties", "have", "more", "than", "20", "hosts", "?", "Give", "me", "the", "host", "names", "for", "these", "parties", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 1], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 12, false], null], [0, 7, false], null], "and", [false, 2, [0, [0, 11, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 8, false], null]]]], "where": [[false, 3, [0, [0, 6, false], null], 20.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"party": ["Party_ID", "Party_Theme", "Location", "First_year", "Last_year", "Number_of_hosts"], "host": ["Host_ID", "Name", "Nationality", "Age"], "party_host": ["Party_ID", "Host_ID", "Is_Main_in_Charge"]}, "answer": [["Ed Davis"]], "db_path": "data/spider/database/party_host/party_host.sqlite"}, "annotation": "t1 = pd.merge(party_host, host, left_on='host_id', right_on='host_id', how='left'); t2 = pd.merge(t1, party, left_on='party_id', right_on='party_id', how='left'); answer = t2[t2['number_of_hosts'] > 20]['name']", "exec_result": "4    ed davis\nName: name, dtype: object"}
{"metadata": {"db_id": "game_1", "query": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "query_toks": ["SELECT", "StuID", "FROM", "Sportsinfo", "WHERE", "onscholarship", "=", "'Y", "'"], "query_toks_no_value": ["select", "stuid", "from", "sportsinfo", "where", "onscholarship", "=", "value"], "question": "List ids for all student who are on scholarship.", "question_toks": ["List", "ids", "for", "all", "student", "who", "are", "on", "scholarship", "."], "sql": {"from": {"table_units": [["table_unit", 3]], "conds": []}, "select": [false, [[0, [0, [0, 15, false], null]]]], "where": [[false, 2, [0, [0, 19, false], null], "\"Y\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"], "Video_Games": ["GameID", "GName", "GType"], "Plays_Games": ["StuID", "GameID", "Hours_Played"], "SportsInfo": ["StuID", "SportName", "HoursPerWeek", "GamesPlayed", "OnScholarship"]}, "answer": [[1002], [1003], [1015], [1019], [1023], [1023], [1026], [1033]], "db_path": "data/spider/database/game_1/game_1.sqlite"}, "annotation": "answer = sportsinfo[sportsinfo['onscholarship'] == 'Y']['stuid']", "exec_result": "1     1002\n2     1003\n4     1015\n6     1019\n9     1023\n10    1023\n11    1026\n12    1033\nName: stuid, dtype: int64"}
{"metadata": {"db_id": "icfp_1", "query": "SELECT title FROM papers WHERE title LIKE \"%Database%\"", "query_toks": ["SELECT", "title", "FROM", "papers", "WHERE", "title", "LIKE", "``", "%", "Database", "%", "''"], "query_toks_no_value": ["select", "title", "from", "papers", "where", "title", "like", "value"], "question": "Which paper's title contains the word \"Database\"?", "question_toks": ["Which", "paper", "'s", "title", "contains", "the", "word", "``", "Database", "''", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 8, false], null]]]], "where": [[false, 9, [0, [0, 8, false], null], "\"%Database%\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Inst": ["instID", "name", "country"], "Authors": ["authID", "lname", "fname"], "Papers": ["paperID", "title"], "Authorship": ["authID", "instID", "paperID", "authOrder"]}, "answer": [["Making Standard ML a Practical Database Programming Language"]], "db_path": "data/spider/database/icfp_1/icfp_1.sqlite"}, "annotation": "answer = papers[papers['title'].str.contains('Database', na=False)]['title']", "exec_result": "4    making standard ml a practical database progra...\nName: title, dtype: object"}
{"metadata": {"db_id": "cre_Docs_and_Epenses", "query": "SELECT document_id FROM Documents WHERE document_type_code  =  \"CV\" EXCEPT SELECT document_id FROM Documents_with_expenses", "query_toks": ["SELECT", "document_id", "FROM", "Documents", "WHERE", "document_type_code", "=", "``", "CV", "''", "EXCEPT", "SELECT", "document_id", "FROM", "Documents_with_expenses"], "query_toks_no_value": ["select", "document_id", "from", "documents", "where", "document_type_code", "=", "value", "except", "select", "document_id", "from", "documents_with_expenses"], "question": "Show ids for all documents in type CV without expense budgets.", "question_toks": ["Show", "ids", "for", "all", "documents", "in", "type", "CV", "without", "expense", "budgets", "."], "sql": {"from": {"table_units": [["table_unit", 3]], "conds": []}, "select": [false, [[0, [0, [0, 8, false], null]]]], "where": [[false, 2, [0, [0, 9, false], null], "\"CV\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[0, [0, [0, 17, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}}, "db_table_headers": {"Ref_Document_Types": ["Document_Type_Code", "Document_Type_Name", "Document_Type_Description"], "Ref_Budget_Codes": ["Budget_Type_Code", "Budget_Type_Description"], "Projects": ["Project_ID", "Project_Details"], "Documents": ["Document_ID", "Document_Type_Code", "Project_ID", "Document_Date", "Document_Name", "Document_Description", "Other_Details"], "Statements": ["Statement_ID", "Statement_Details"], "Documents_with_Expenses": ["Document_ID", "Budget_Type_Code", "Document_Details"], "Accounts": ["Account_ID", "Statement_ID", "Account_Details"]}, "answer": [[29]], "db_path": "data/spider/database/cre_Docs_and_Epenses/cre_Docs_and_Epenses.sqlite"}, "annotation": "answer = documents[(documents['document_type_code'] == 'CV') & (~documents['document_id'].isin(documents_with_expenses['document_id']))]['document_id']", "exec_result": "0    29\nName: document_id, dtype: int64"}
{"metadata": {"db_id": "club_1", "query": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "club", "AS", "t1", "JOIN", "member_of_club", "AS", "t2", "ON", "t1.clubid", "=", "t2.clubid", "JOIN", "student", "AS", "t3", "ON", "t2.stuid", "=", "t3.stuid", "WHERE", "t3.fname", "=", "``", "Linda", "''", "AND", "t3.lname", "=", "``", "Smith", "''"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "club", "as", "t1", "join", "member_of_club", "as", "t2", "on", "t1", ".", "clubid", "=", "t2", ".", "clubid", "join", "student", "as", "t3", "on", "t2", ".", "stuid", "=", "t3", ".", "stuid", "where", "t3", ".", "fname", "=", "value", "and", "t3", ".", "lname", "=", "value"], "question": "How many clubs does \"Linda Smith\" belong to?", "question_toks": ["How", "many", "clubs", "does", "``", "Linda", "Smith", "''", "belong", "to", "?"], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 2], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 9, false], null], [0, 14, false], null], "and", [false, 2, [0, [0, 13, false], null], [0, 1, false], null]]}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 2, [0, [0, 3, false], null], "\"Linda\"", null], "and", [false, 2, [0, [0, 2, false], null], "\"Smith\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Student": ["StuID", "LName", "Fname", "Age", "Sex", "Major", "Advisor", "city_code"], "Club": ["ClubID", "ClubName", "ClubDesc", "ClubLocation"], "Member_of_club": ["StuID", "ClubID", "Position"]}, "answer": [[1]], "db_path": "data/spider/database/club_1/club_1.sqlite"}, "annotation": "t1 = pd.merge(club, member_of_club, left_on='clubid', right_on='clubid', how='left'); t2 = pd.merge(t1, student, left_on='stuid', right_on='stuid', how='left'); answer = t2[(t2['fname'] == 'Linda') & (t2['lname'] == 'Smith')].shape[0]", "exec_result": "1"}
{"metadata": {"db_id": "ship_1", "query": "SELECT t1.name FROM ship AS t1 JOIN captain AS t2 ON t1.ship_id  =  t2.ship_id ORDER BY t2.age LIMIT 1", "query_toks": ["SELECT", "t1.name", "FROM", "ship", "AS", "t1", "JOIN", "captain", "AS", "t2", "ON", "t1.ship_id", "=", "t2.ship_id", "ORDER", "BY", "t2.age", "LIMIT", "1"], "query_toks_no_value": ["select", "t1", ".", "name", "from", "ship", "as", "t1", "join", "captain", "as", "t2", "on", "t1", ".", "ship_id", "=", "t2", ".", "ship_id", "order", "by", "t2", ".", "age", "limit", "value"], "question": "Find the name of the ship that is steered by the youngest captain.", "question_toks": ["Find", "the", "name", "of", "the", "ship", "that", "is", "steered", "by", "the", "youngest", "captain", "."], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 7, false], null], [0, 3, false], null]]}, "select": [false, [[0, [0, [0, 8, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["asc", [[0, [0, 4, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"captain": ["Captain_ID", "Name", "Ship_ID", "age", "Class", "Rank"], "Ship": ["Ship_ID", "Name", "Type", "Built_Year", "Class", "Flag"]}, "answer": [["HMS Destiny"]], "db_path": "data/spider/database/ship_1/ship_1.sqlite"}, "annotation": "t1 = pd.merge(ship, captain, left_on='ship_id', right_on='ship_id', how='left'); answer = t1.sort_values(by='name_x', ascending=False, kind='mergesort').sort_values(by='age', ascending=True, kind='mergesort').iloc[0]['name_x']", "exec_result": "hms destiny"}
{"metadata": {"db_id": "journal_committee", "query": "SELECT count(*) FROM editor", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "editor"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "editor"], "question": "How many editors are there?", "question_toks": ["How", "many", "editors", "are", "there", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"journal": ["Journal_ID", "Date", "Theme", "Sales"], "editor": ["Editor_ID", "Name", "Age"], "journal_committee": ["Editor_ID", "Journal_ID", "Work_Type"]}, "answer": [[9]], "pandas_converted": "pd.Series(editor.shape[0])", "db_path": "data/spider/database/journal_committee/journal_committee.sqlite"}, "annotation": "answer = editor.shape[0]", "exec_result": "9"}
{"metadata": {"db_id": "cre_Drama_Workshop_Groups", "query": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  \"MasterCard\"", "query_toks": ["SELECT", "avg", "(", "Order_Quantity", ")", "FROM", "Invoices", "WHERE", "payment_method_code", "=", "``", "MasterCard", "''"], "query_toks_no_value": ["select", "avg", "(", "order_quantity", ")", "from", "invoices", "where", "payment_method_code", "=", "value"], "question": "Check the invoices record and compute the average quantities ordered with the payment method \"MasterCard\".", "question_toks": ["Check", "the", "invoices", "record", "and", "compute", "the", "average", "quantities", "ordered", "with", "the", "payment", "method", "``", "MasterCard", "''", "."], "sql": {"from": {"table_units": [["table_unit", 14]], "conds": []}, "select": [false, [[5, [0, [0, 81, false], null]]]], "where": [[false, 2, [0, [0, 79, false], null], "\"MasterCard\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Payment_Methods": ["payment_method_code", "payment_method_description"], "Ref_Service_Types": ["Service_Type_Code", "Parent_Service_Type_Code", "Service_Type_Description"], "Addresses": ["Address_ID", "Line_1", "Line_2", "City_Town", "State_County", "Other_Details"], "Products": ["Product_ID", "Product_Name", "Product_Price", "Product_Description", "Other_Product_Service_Details"], "Marketing_Regions": ["Marketing_Region_Code", "Marketing_Region_Name", "Marketing_Region_Descriptrion", "Other_Details"], "Clients": ["Client_ID", "Address_ID", "Customer_Email_Address", "Customer_Name", "Customer_Phone", "Other_Details"], "Drama_Workshop_Groups": ["Workshop_Group_ID", "Address_ID", "Currency_Code", "Marketing_Region_Code", "Store_Name", "Store_Phone", "Store_Email_Address", "Other_Details"], "Performers": ["Performer_ID", "Address_ID", "Customer_Name", "Customer_Phone", "Customer_Email_Address", "Other_Details"], "Customers": ["Customer_ID", "Address_ID", "Customer_Name", "Customer_Phone", "Customer_Email_Address", "Other_Details"], "Stores": ["Store_ID", "Address_ID", "Marketing_Region_Code", "Store_Name", "Store_Phone", "Store_Email_Address", "Other_Details"], "Bookings": ["Booking_ID", "Customer_ID", "Workshop_Group_ID", "Status_Code", "Store_ID", "Order_Date", "Planned_Delivery_Date", "Actual_Delivery_Date", "Other_Order_Details"], "Performers_in_Bookings": ["Order_ID", "Performer_ID"], "Customer_Orders": ["Order_ID", "Customer_ID", "Store_ID", "Order_Date", "Planned_Delivery_Date", "Actual_Delivery_Date", "Other_Order_Details"], "Order_Items": ["Order_Item_ID", "Order_ID", "Product_ID", "Order_Quantity", "Other_Item_Details"], "Invoices": ["Invoice_ID", "Order_ID", "payment_method_code", "Product_ID", "Order_Quantity", "Other_Item_Details", "Order_Item_ID"], "Services": ["Service_ID", "Service_Type_Code", "Workshop_Group_ID", "Product_Description", "Product_Name", "Product_Price", "Other_Product_Service_Details"], "Bookings_Services": ["Order_ID", "Product_ID"], "Invoice_Items": ["Invoice_Item_ID", "Invoice_ID", "Order_ID", "Order_Item_ID", "Product_ID", "Order_Quantity", "Other_Item_Details"]}, "answer": [[1.8333333333333333]], "db_path": "data/spider/database/cre_Drama_Workshop_Groups/cre_Drama_Workshop_Groups.sqlite"}, "annotation": "answer = invoices[invoices['payment_method_code'] == 'mastercard']['order_quantity'].astype(float).mean()", "exec_result": "1.8333333333333333"}
{"metadata": {"db_id": "insurance_policies", "query": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC", "query_toks": ["SELECT", "Payment_Method_Code", ",", "Date_Payment_Made", ",", "Amount_Payment", "FROM", "Payments", "ORDER", "BY", "Date_Payment_Made", "ASC"], "query_toks_no_value": ["select", "payment_method_code", ",", "date_payment_made", ",", "amount_payment", "from", "payments", "order", "by", "date_payment_made", "asc"], "question": "List the method, date and amount of all the payments, in ascending order of date.", "question_toks": ["List", "the", "method", ",", "date", "and", "amount", "of", "all", "the", "payments", ",", "in", "ascending", "order", "of", "date", "."], "sql": {"from": {"table_units": [["table_unit", 4]], "conds": []}, "select": [false, [[0, [0, [0, 23, false], null]], [0, [0, [0, 24, false], null]], [0, [0, [0, 25, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["asc", [[0, [0, 24, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Customers": ["Customer_ID", "Customer_Details"], "Customer_Policies": ["Policy_ID", "Customer_ID", "Policy_Type_Code", "Start_Date", "End_Date"], "Claims": ["Claim_ID", "Policy_ID", "Date_Claim_Made", "Date_Claim_Settled", "Amount_Claimed", "Amount_Settled"], "Settlements": ["Settlement_ID", "Claim_ID", "Date_Claim_Made", "Date_Claim_Settled", "Amount_Claimed", "Amount_Settled", "Customer_Policy_ID"], "Payments": ["Payment_ID", "Settlement_ID", "Payment_Method_Code", "Date_Payment_Made", "Amount_Payment"]}, "answer": [["Visa", "2017-05-03", 172309], ["Discover Card", "2017-05-04", 123255], ["MasterCard", "2017-05-28", 448613], ["Visa", "2017-05-28", 155654], ["MasterCard", "2017-06-24", 456098], ["MasterCard", "2017-07-31", 423154], ["Discover Card", "2017-08-06", 38324], ["Discover Card", "2017-10-07", 71246], ["Visa", "2017-12-16", 459407], ["MasterCard", "2018-01-10", 407235], ["American Express", "2018-01-19", 177130], ["MasterCard", "2018-01-28", 319142], ["MasterCard", "2018-02-16", 241730], ["MasterCard", "2018-02-18", 235893], ["Visa", "2018-02-24", 7343]], "db_path": "data/spider/database/insurance_policies/insurance_policies.sqlite"}, "annotation": "t1 = payments.sort_values(by='date_payment_made', ascending=True, kind='mergesort'); answer = [list(item) for item in zip(t1['payment_method_code'], t1['date_payment_made'], t1['amount_payment'])]", "exec_result": "[['visa', '2017-05-03', 172309], ['discover card', '2017-05-04', 123255], ['mastercard', '2017-05-28', 448613], ['visa', '2017-05-28', 155654], ['mastercard', '2017-06-24', 456098], ['mastercard', '2017-07-31', 423154], ['discover card', '2017-08-06', 38324], ['discover card', '2017-10-07', 71246], ['visa', '2017-12-16', 459407], ['mastercard', '2018-01-10', 407235], ['american express', '2018-01-19', 177130], ['mastercard', '2018-01-28', 319142], ['mastercard', '2018-02-16', 241730], ['mastercard', '2018-02-18', 235893], ['visa', '2018-02-24', 7343]]"}
{"metadata": {"db_id": "college_2", "query": "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)", "query_toks": ["SELECT", "title", "FROM", "course", "WHERE", "course_id", "NOT", "IN", "(", "SELECT", "course_id", "FROM", "prereq", ")"], "query_toks_no_value": ["select", "title", "from", "course", "where", "course_id", "not", "in", "(", "select", "course_id", "from", "prereq", ")"], "question": "Find the name of the courses that do not have any prerequisite?", "question_toks": ["Find", "the", "name", "of", "the", "courses", "that", "do", "not", "have", "any", "prerequisite", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 8, false], null]]]], "where": [[true, 8, [0, [0, 7, false], null], {"from": {"table_units": [["table_unit", 10]], "conds": []}, "select": [false, [[0, [0, [0, 45, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"classroom": ["building", "room_number", "capacity"], "department": ["dept_name", "building", "budget"], "course": ["course_id", "title", "dept_name", "credits"], "instructor": ["ID", "name", "dept_name", "salary"], "section": ["course_id", "sec_id", "semester", "year", "building", "room_number", "time_slot_id"], "teaches": ["ID", "course_id", "sec_id", "semester", "year"], "student": ["ID", "name", "dept_name", "tot_cred"], "takes": ["ID", "course_id", "sec_id", "semester", "year", "grade"], "advisor": ["s_ID", "i_ID"], "time_slot": ["time_slot_id", "day", "start_hr", "start_min", "end_hr", "end_min"], "prereq": ["course_id", "prereq_id"]}, "answer": [["C  Programming"], ["The Music of Donovan"], ["International Finance"], ["Greek Tragedy"], ["Virology"], ["Compiler Design"], ["Surfing"], ["Latin"], ["Composition and Literature"], ["Music of the 50s"], ["Visual BASIC"], ["The Monkeys"], ["FOCAL Programming"], ["Calculus"], ["The Beatles"], ["World History"], ["Tort Law"], ["Corporate Law"], ["Video Gaming"], ["Bankruptcy"], ["Organic Chemistry"], ["Quantum Mechanics"], ["Quantum Mechanics"], ["The IBM 360 Architecture"], ["Electricity and Magnetism"], ["Elastic Structures"], ["Computational Biology"], ["Journalism"], ["Physical Chemistry"], ["Image Processing"], ["Industrial Organization"], ["Sanitary Engineering"], ["Thermodynamics"], ["Japanese"], ["International Trade"], ["Database System Concepts"], ["Romantic Literature"], ["Religion"], ["Existentialism"], ["Compiler Design"], ["Geology"], ["C  Programming"], ["Manufacturing"], ["Drama"], ["Medieval Civilization or Lack Thereof"], ["Differential Geometry"], ["Bacteriology"], ["International Trade"], ["Aquatic Chemistry"], ["Number Theory"], ["Sailing"], ["Physical Chemistry"], ["Hydraulics"], ["The Music of the Ramones"], ["Mechanics"], ["Hebrew"], ["Computability Theory"], ["Creative Writing"], ["The Monkeys"], ["Differential Geometry"], ["Virology"], ["Geology"], ["Stream Processing"], ["The Music of Donovan"], ["Petroleum Engineering"], ["Systems Software"], ["Environmental Law"], ["Data Mining"], ["Medieval Civilization or Lack Thereof"], ["Differential Geometry"], ["International Communication"], ["Diffusion and Phase Transformation"], ["Differential Equations"], ["Compiler Design"], ["Aerodynamics"], ["The Music of Dave Edmunds"], ["Computability Theory"], ["Cognitive Psychology"], ["Tort Law"], ["European History"], ["Corporate Law"], ["Multimedia Design"], ["Animal Behavior"], ["Graphics"], ["Romantic Literature"], ["Banking and Finance"], ["Astronautics"], ["How to Succeed in Business Without Really Trying"], ["Race Car Driving"], ["Milton"], ["Topology"], ["Video Gaming"], ["Logic"], ["Thermal Physics"], ["Differential Geometry"], ["The Music of Dave Edmunds"], ["Greek Tragedy"], ["Arabic"], ["Compiler Design"], ["Networking"], ["Automobile Mechanics"], ["Music of the 50s"], ["C  Programming"], ["Groups and Rings"], ["Biostatistics"], ["UNIX System Programmming"], ["UNIX System Programmming"], ["Music 2 New for your Instructor"], ["Microeconomics"], ["Plastics"], ["Number Theory"], ["Multivariable Calculus"], ["Numerical Methods"], ["Operating Systems"], ["Numerical Methods"], ["Strength of Materials"], ["Fractal Geometry"], ["Music of the 90s"], ["Sanitary Engineering"], ["The Music of Donovan"], ["Quantum Mechanics"]], "db_path": "data/spider/database/college_2/college_2.sqlite"}, "annotation": "answer = course[~course['course_id'].isin(prereq['course_id'])]['title']", "exec_result": "0             c  programming\n1       the music of donovan\n3      international finance\n4              greek tragedy\n6                   virology\n               ...          \n191         fractal geometry\n192         music of the 90s\n193     sanitary engineering\n197     the music of donovan\n198        quantum mechanics\nName: title, Length: 121, dtype: object"}
{"metadata": {"db_id": "movie_1", "query": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name", "query_toks": ["SELECT", "DISTINCT", "T3.name", ",", "T2.title", ",", "T1.stars", "FROM", "Rating", "AS", "T1", "JOIN", "Movie", "AS", "T2", "ON", "T1.mID", "=", "T2.mID", "JOIN", "Reviewer", "AS", "T3", "ON", "T1.rID", "=", "T3.rID", "WHERE", "T2.director", "=", "T3.name"], "query_toks_no_value": ["select", "distinct", "t3", ".", "name", ",", "t2", ".", "title", ",", "t1", ".", "stars", "from", "rating", "as", "t1", "join", "movie", "as", "t2", "on", "t1", ".", "mid", "=", "t2", ".", "mid", "join", "reviewer", "as", "t3", "on", "t1", ".", "rid", "=", "t3", ".", "rid", "where", "t2", ".", "director", "=", "t3", ".", "name"], "question": "For any rating where the name of reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars.", "question_toks": ["For", "any", "rating", "where", "the", "name", "of", "reviewer", "is", "the", "same", "as", "the", "director", "of", "the", "movie", ",", "return", "the", "reviewer", "name", ",", "movie", "title", ",", "and", "number", "of", "stars", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 0], ["table_unit", 1]], "conds": [[false, 2, [0, [0, 8, false], null], [0, 1, false], null], "and", [false, 2, [0, [0, 7, false], null], [0, 5, false], null]]}, "select": [true, [[0, [0, [0, 6, false], null]], [0, [0, [0, 2, false], null]], [0, [0, [0, 9, false], null]]]], "where": [[false, 2, [0, [0, 4, false], null], [0, 6, false], null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Movie": ["mID", "title", "year", "director"], "Reviewer": ["rID", "name"], "Rating": ["rID", "mID", "stars", "ratingDate"]}, "answer": [["James Cameron", "Avatar", 5]], "db_path": "data/spider/database/movie_1/movie_1.sqlite"}, "annotation": "t1 = pd.merge(rating, movie, left_on='mid', right_on='mid', how='left'); t2 = pd.merge(t1, reviewer, left_on='rid', right_on='rid', how='left'); t3 = t2[t2['director'] == t2['name']].drop_duplicates(); answer = [list(item) for item in zip(t3['name'], t3['title'], t3['stars'])]", "exec_result": "[['james cameron', 'avatar', 5]]"}
{"metadata": {"db_id": "formula_1", "query": "SELECT name FROM races WHERE YEAR = 2017", "query_toks": ["SELECT", "name", "FROM", "races", "WHERE", "YEAR", "=", "2017"], "query_toks_no_value": ["select", "name", "from", "races", "where", "year", "=", "value"], "question": "What are the names of all the races that occurred in the year 2017?", "question_toks": ["What", "are", "the", "names", "of", "all", "the", "races", "that", "occurred", "in", "the", "year", "2017", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 14, false], null]]]], "where": [[false, 2, [0, [0, 11, false], null], 2017.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"circuits": ["circuitId", "circuitRef", "name", "location", "country", "lat", "lng", "alt", "url"], "races": ["raceId", "year", "round", "circuitId", "name", "date", "time", "url"], "drivers": ["driverId", "driverRef", "number", "code", "forename", "surname", "dob", "nationality", "url"], "status": ["statusId", "status"], "seasons": ["year", "url"], "constructors": ["constructorId", "constructorRef", "name", "nationality", "url"], "constructorStandings": ["constructorStandingsId", "raceId", "constructorId", "points", "position", "positionText", "wins"], "results": ["resultId", "raceId", "driverId", "constructorId", "number", "grid", "position", "positionText", "positionOrder", "points", "laps", "time", "milliseconds", "fastestLap", "rank", "fastestLapTime", "fastestLapSpeed", "statusId"], "driverStandings": ["driverStandingsId", "raceId", "driverId", "points", "position", "positionText", "wins"], "constructorResults": ["constructorResultsId", "raceId", "constructorId", "points", "status"], "qualifying": ["qualifyId", "raceId", "driverId", "constructorId", "number", "position", "q1", "q2", "q3"], "pitStops": ["raceId", "driverId", "stop", "lap", "time", "duration", "milliseconds"], "lapTimes": ["raceId", "driverId", "lap", "position", "time", "milliseconds"]}, "answer": [["Australian Grand Prix"], ["Chinese Grand Prix"], ["Bahrain Grand Prix"], ["Russian Grand Prix"], ["Spanish Grand Prix"], ["Monaco Grand Prix"], ["Canadian Grand Prix"], ["Azerbaijan Grand Prix"], ["Austrian Grand Prix"], ["British Grand Prix"], ["Hungarian Grand Prix"], ["Belgian Grand Prix"], ["Italian Grand Prix"], ["Singapore Grand Prix"], ["Malaysian Grand Prix"], ["Japanese Grand Prix"], ["United States Grand Prix"], ["Mexican Grand Prix"], ["Brazilian Grand Prix"], ["Abu Dhabi Grand Prix"]], "db_path": "data/spider/database/formula_1/formula_1.sqlite"}, "annotation": "answer = races[races['year'] == 2017]['name']", "exec_result": "956       australian grand prix\n957          chinese grand prix\n958          bahrain grand prix\n959          russian grand prix\n960          spanish grand prix\n961           monaco grand prix\n962         canadian grand prix\n963       azerbaijan grand prix\n964         austrian grand prix\n965          british grand prix\n966        hungarian grand prix\n967          belgian grand prix\n968          italian grand prix\n969        singapore grand prix\n970        malaysian grand prix\n971         japanese grand prix\n972    united states grand prix\n973          mexican grand prix\n974        brazilian grand prix\n975        abu dhabi grand prix\nName: name, dtype: object"}
{"metadata": {"db_id": "college_1", "query": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "query_toks": ["SELECT", "T1.school_code", "FROM", "department", "AS", "T1", "JOIN", "professor", "AS", "T2", "ON", "T1.dept_code", "=", "T2.dept_code", "GROUP", "BY", "T1.school_code", "ORDER", "BY", "count", "(", "*", ")", "LIMIT", "1"], "query_toks_no_value": ["select", "t1", ".", "school_code", "from", "department", "as", "t1", "join", "professor", "as", "t2", "on", "t1", ".", "dept_code", "=", "t2", ".", "dept_code", "group", "by", "t1", ".", "school_code", "order", "by", "count", "(", "*", ")", "limit", "value"], "question": "Which school has the fewest professors?", "question_toks": ["Which", "school", "has", "the", "fewest", "professors", "?"], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 5]], "conds": [[false, 2, [0, [0, 11, false], null], [0, 28, false], null]]}, "select": [false, [[0, [0, [0, 13, false], null]]]], "where": [], "groupBy": [[0, 13, false]], "having": [], "orderBy": ["asc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"CLASS": ["CLASS_CODE", "CRS_CODE", "CLASS_SECTION", "CLASS_TIME", "CLASS_ROOM", "PROF_NUM"], "COURSE": ["CRS_CODE", "DEPT_CODE", "CRS_DESCRIPTION", "CRS_CREDIT"], "DEPARTMENT": ["DEPT_CODE", "DEPT_NAME", "SCHOOL_CODE", "EMP_NUM", "DEPT_ADDRESS", "DEPT_EXTENSION"], "EMPLOYEE": ["EMP_NUM", "EMP_LNAME", "EMP_FNAME", "EMP_INITIAL", "EMP_JOBCODE", "EMP_HIREDATE", "EMP_DOB"], "ENROLL": ["CLASS_CODE", "STU_NUM", "ENROLL_GRADE"], "PROFESSOR": ["EMP_NUM", "DEPT_CODE", "PROF_OFFICE", "PROF_EXTENSION", "PROF_HIGH_DEGREE"], "STUDENT": ["STU_NUM", "STU_LNAME", "STU_FNAME", "STU_INIT", "STU_DOB", "STU_HRS", "STU_CLASS", "STU_GPA", "STU_TRANSFER", "DEPT_CODE", "STU_PHONE", "PROF_NUM"]}, "answer": [["BUS"]], "db_path": "data/spider/database/college_1/college_1.sqlite"}, "annotation": "t1 = pd.merge(department, professor, left_on='dept_code', right_on='dept_code', how='left'); answer = t1.groupby('school_code').size().sort_values(ascending=True, kind='mergesort').index[0]", "exec_result": "bus"}
{"metadata": {"db_id": "cinema", "query": "SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity  >  800", "query_toks": ["SELECT", "LOCATION", "FROM", "cinema", "EXCEPT", "SELECT", "LOCATION", "FROM", "cinema", "WHERE", "capacity", ">", "800"], "query_toks_no_value": ["select", "location", "from", "cinema", "except", "select", "location", "from", "cinema", "where", "capacity", ">", "value"], "question": "Show all the locations where no cinema has capacity over 800.", "question_toks": ["Show", "all", "the", "locations", "where", "no", "cinema", "has", "capacity", "over", "800", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 12, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 12, false], null]]]], "where": [[false, 3, [0, [0, 11, false], null], 800.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}}, "db_table_headers": {"film": ["Film_ID", "Rank_in_series", "Number_in_season", "Title", "Directed_by", "Original_air_date", "Production_code"], "cinema": ["Cinema_ID", "Name", "Openning_year", "Capacity", "Location"], "schedule": ["Cinema_ID", "Film_ID", "Date", "Show_times_per_day", "Price"]}, "answer": [["County Cork"], ["County Dublin"], ["County Laois"], ["County Louth"], ["County Tipperary"]], "db_path": "data/spider/database/cinema/cinema.sqlite"}, "annotation": "answer = cinema[~cinema['location'].isin(cinema[cinema['capacity'] > 800]['location'])]['location'].drop_duplicates()", "exec_result": "1         county cork\n2       county dublin\n4    county tipperary\n5        county laois\n9        county louth\nName: location, dtype: object"}
{"metadata": {"db_id": "election_representative", "query": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID ORDER BY votes DESC", "query_toks": ["SELECT", "T2.Name", "FROM", "election", "AS", "T1", "JOIN", "representative", "AS", "T2", "ON", "T1.Representative_ID", "=", "T2.Representative_ID", "ORDER", "BY", "votes", "DESC"], "query_toks_no_value": ["select", "t2", ".", "name", "from", "election", "as", "t1", "join", "representative", "as", "t2", "on", "t1", ".", "representative_id", "=", "t2", ".", "representative_id", "order", "by", "votes", "desc"], "question": "What are the names of representatives in descending order of votes?", "question_toks": ["What", "are", "the", "names", "of", "representatives", "in", "descending", "order", "of", "votes", "?"], "sql": {"from": {"table_units": [["table_unit", 0], ["table_unit", 1]], "conds": [[false, 2, [0, [0, 2, false], null], [0, 8, false], null]]}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 4, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"election": ["Election_ID", "Representative_ID", "Date", "Votes", "Vote_Percent", "Seats", "Place"], "representative": ["Representative_ID", "Name", "State", "Party", "Lifespan"]}, "answer": [["Jimmy Quillen"], ["James M. Quigley"], ["James L. Quinn"], ["John Quayle"], ["Dan Quayle"]], "db_path": "data/spider/database/election_representative/election_representative.sqlite"}, "annotation": "t1 = pd.merge(election, representative, left_on='representative_id', right_on='representative_id', how='left'); answer = t1.sort_values(by='votes', ascending=False, kind='mergesort')['name']", "exec_result": "3       jimmy quillen\n2    james m. quigley\n4      james l. quinn\n1         john quayle\n0          dan quayle\nName: name, dtype: object"}
{"metadata": {"db_id": "insurance_policies", "query": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "query_toks": ["SELECT", "Payment_Method_Code", "FROM", "Payments", "GROUP", "BY", "Payment_Method_Code", "ORDER", "BY", "count", "(", "*", ")", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "payment_method_code", "from", "payments", "group", "by", "payment_method_code", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "What is the most popular payment method?", "question_toks": ["What", "is", "the", "most", "popular", "payment", "method", "?"], "sql": {"from": {"table_units": [["table_unit", 4]], "conds": []}, "select": [false, [[0, [0, [0, 23, false], null]]]], "where": [], "groupBy": [[0, 23, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Customers": ["Customer_ID", "Customer_Details"], "Customer_Policies": ["Policy_ID", "Customer_ID", "Policy_Type_Code", "Start_Date", "End_Date"], "Claims": ["Claim_ID", "Policy_ID", "Date_Claim_Made", "Date_Claim_Settled", "Amount_Claimed", "Amount_Settled"], "Settlements": ["Settlement_ID", "Claim_ID", "Date_Claim_Made", "Date_Claim_Settled", "Amount_Claimed", "Amount_Settled", "Customer_Policy_ID"], "Payments": ["Payment_ID", "Settlement_ID", "Payment_Method_Code", "Date_Payment_Made", "Amount_Payment"]}, "answer": [["MasterCard"]], "db_path": "data/spider/database/insurance_policies/insurance_policies.sqlite"}, "annotation": "answer = payments.groupby('payment_method_code').size().sort_values(ascending=False, kind='mergesort').index[0]", "exec_result": "mastercard"}
