{"db_id": "concert_singer", "query": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id", "query_toks": ["SELECT", "T2.name", ",", "count", "(", "*", ")", "FROM", "concert", "AS", "T1", "JOIN", "stadium", "AS", "T2", "ON", "T1.stadium_id", "=", "T2.stadium_id", "GROUP", "BY", "T1.stadium_id"], "query_toks_no_value": ["select", "t2", ".", "name", ",", "count", "(", "*", ")", "from", "concert", "as", "t1", "join", "stadium", "as", "t2", "on", "t1", ".", "stadium_id", "=", "t2", ".", "stadium_id", "group", "by", "t1", ".", "stadium_id"], "question": "Show the stadium name and the number of concerts in each stadium.", "question_toks": ["Show", "the", "stadium", "name", "and", "the", "number", "of", "concerts", "in", "each", "stadium", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 18, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 3, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 18, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"stadium": ["Stadium_ID", "Location", "Name", "Capacity", "Highest", "Lowest", "Average"], "singer": ["Singer_ID", "Name", "Country", "Song_Name", "Song_release_year", "Age", "Is_male"], "concert": ["concert_ID", "concert_Name", "Theme", "Stadium_ID", "Year"], "singer_in_concert": ["concert_ID", "Singer_ID"]}, "answer": [["Stark's Park", 1], ["Glebe Park", 1], ["Somerset Park", 2], ["Recreation Park", 1], ["Balmoor", 1]], "results": {"generated_sql": "SELECT T1.name ,  count(*) FROM stadium AS T1 JOIN concert AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id", "generated_py": "t1 = pd.merge(concert, stadium, left_on='stadium_id', right_on='stadium_id')\nt2 = t1.groupby('name').size().rename('count')\nanswer = t2.to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: You are trying to merge on object and int64 columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(\"Stark's Park\", 1), ('Somerset Park', 2), ('Recreation Park', 1), ('Balmoor', 1), ('Glebe Park', 1)]", "py_exec_result": "None", "gold_answer": [["Stark's Park", 1], ["Glebe Park", 1], ["Somerset Park", 2], ["Recreation Park", 1], ["Balmoor", 1]], "gold_sql": "SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id", "table_headers": {"stadium": ["Stadium_ID", "Location", "Name", "Capacity", "Highest", "Lowest", "Average"], "singer": ["Singer_ID", "Name", "Country", "Song_Name", "Song_release_year", "Age", "Is_male"], "concert": ["concert_ID", "concert_Name", "Theme", "Stadium_ID", "Year"], "singer_in_concert": ["concert_ID", "Singer_ID"]}, "gold_py": null}}
{"db_id": "flight_2", "query": "SELECT count(*) FROM AIRLINES", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "AIRLINES"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "airlines"], "question": "What is the total number of airlines?", "question_toks": ["What", "is", "the", "total", "number", "of", "airlines", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "answer": [[12]], "results": {"generated_sql": "SELECT count(*) FROM airlines", "generated_py": "answer = pd.Series(airlines.shape[0])", "sql_error": null, "py_error": "ERROR: You are trying to merge on object and int64 columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(12,)]", "py_exec_result": "0    12\ndtype: int64", "gold_answer": [[12]], "gold_sql": "SELECT count(*) FROM AIRLINES", "table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "gold_py": null}}
{"db_id": "dog_kennels", "query": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2", "query_toks": ["SELECT", "professional_id", ",", "last_name", ",", "cell_number", "FROM", "Professionals", "WHERE", "state", "=", "'Indiana", "'", "UNION", "SELECT", "T1.professional_id", ",", "T1.last_name", ",", "T1.cell_number", "FROM", "Professionals", "AS", "T1", "JOIN", "Treatments", "AS", "T2", "ON", "T1.professional_id", "=", "T2.professional_id", "GROUP", "BY", "T1.professional_id", "HAVING", "count", "(", "*", ")", ">", "2"], "query_toks_no_value": ["select", "professional_id", ",", "last_name", ",", "cell_number", "from", "professionals", "where", "state", "=", "value", "union", "select", "t1", ".", "professional_id", ",", "t1", ".", "last_name", ",", "t1", ".", "cell_number", "from", "professionals", "as", "t1", "join", "treatments", "as", "t2", "on", "t1", ".", "professional_id", "=", "t2", ".", "professional_id", "group", "by", "t1", ".", "professional_id", "having", "count", "(", "*", ")", ">", "value"], "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.", "question_toks": ["Which", "professionals", "live", "in", "the", "state", "of", "Indiana", "or", "have", "done", "treatment", "on", "more", "than", "2", "treatments", "?", "List", "his", "or", "her", "id", ",", "last", "name", "and", "cell", "phone", "."], "sql": {"from": {"table_units": [["table_unit", 6]], "conds": []}, "select": [false, [[0, [0, [0, 33, false], null]], [0, [0, [0, 40, false], null]], [0, [0, [0, 43, false], null]]]], "where": [[false, 2, [0, [0, 38, false], null], "\"Indiana\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": {"from": {"table_units": [["table_unit", 6], ["table_unit", 7]], "conds": [[false, 2, [0, [0, 33, false], null], [0, 46, false], null]]}, "select": [false, [[0, [0, [0, 33, false], null]], [0, [0, [0, 40, false], null]], [0, [0, [0, 43, false], null]]]], "where": [], "groupBy": [[0, 33, false]], "having": [[false, 3, [0, [3, 0, false], null], 2.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "except": null}, "db_table_headers": {"Breeds": ["breed_code", "breed_name"], "Charges": ["charge_id", "charge_type", "charge_amount"], "Sizes": ["size_code", "size_description"], "Treatment_Types": ["treatment_type_code", "treatment_type_description"], "Owners": ["owner_id", "first_name", "last_name", "street", "city", "state", "zip_code", "email_address", "home_phone", "cell_number"], "Dogs": ["dog_id", "owner_id", "abandoned_yn", "breed_code", "size_code", "name", "age", "date_of_birth", "gender", "weight", "date_arrived", "date_adopted", "date_departed"], "Professionals": ["professional_id", "role_code", "first_name", "street", "city", "state", "zip_code", "last_name", "email_address", "home_phone", "cell_number"], "Treatments": ["treatment_id", "dog_id", "professional_id", "treatment_type_code", "date_of_treatment", "cost_of_treatment"]}, "answer": [[1, "Braun", "(275)939-2435x80863"], [8, "Hyatt", "328.842.3792"], [9, "Kshlerin", "962-983-8109x3509"]], "results": {"generated_sql": "SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM professionals AS T1 JOIN treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2 OR T1.state  =  'Indiana'", "generated_py": "t1 = pd.merge(Professionals, Treatments, left_on='professional_id', right_on='professional_id')\nt2 = t1.groupby('professional_id').size().rename('count')\nt3 = t2[t2 > 2].to_frame().reset_index()\nt4 = pd.merge(Professionals, t3, left_on='professional_id', right_on='professional_id')\nt5 = t4[t4['state'] == 'Indiana']\nanswer = t5[['professional_id', 'last_name', 'cell_number']]", "sql_error": null, "py_error": "ERROR: You are trying to merge on object and int64 columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(8, 'Hyatt', '328.842.3792'), (9, 'Kshlerin', '962-983-8109x3509')]", "py_exec_result": "Empty DataFrame\nColumns: [professional_id, last_name, cell_number]\nIndex: []", "gold_answer": [[1, "Braun", "(275)939-2435x80863"], [8, "Hyatt", "328.842.3792"], [9, "Kshlerin", "962-983-8109x3509"]], "gold_sql": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2", "table_headers": {"Breeds": ["breed_code", "breed_name"], "Charges": ["charge_id", "charge_type", "charge_amount"], "Sizes": ["size_code", "size_description"], "Treatment_Types": ["treatment_type_code", "treatment_type_description"], "Owners": ["owner_id", "first_name", "last_name", "street", "city", "state", "zip_code", "email_address", "home_phone", "cell_number"], "Dogs": ["dog_id", "owner_id", "abandoned_yn", "breed_code", "size_code", "name", "age", "date_of_birth", "gender", "weight", "date_arrived", "date_adopted", "date_departed"], "Professionals": ["professional_id", "role_code", "first_name", "street", "city", "state", "zip_code", "last_name", "email_address", "home_phone", "cell_number"], "Treatments": ["treatment_id", "dog_id", "professional_id", "treatment_type_code", "date_of_treatment", "cost_of_treatment"]}, "gold_py": null}}
{"db_id": "student_transcripts_tracking", "query": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "query_toks": ["SELECT", "count", "(", "*", ")", ",", "student_course_id", "FROM", "Transcript_Contents", "GROUP", "BY", "student_course_id", "ORDER", "BY", "count", "(", "*", ")", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "count", "(", "*", ")", ",", "student_course_id", "from", "transcript_contents", "group", "by", "student_course_id", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.", "question_toks": ["How", "many", "times", "at", "most", "can", "a", "course", "enrollment", "result", "show", "in", "different", "transcripts", "?", "Also", "show", "the", "course", "enrollment", "id", "."], "sql": {"from": {"table_units": [["table_unit", 10]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]], [0, [0, [0, 55, false], null]]]], "where": [], "groupBy": [[0, 55, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "answer": [[4, 0]], "results": {"generated_sql": "SELECT student_course_id ,  count(*) FROM transcript_contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "generated_py": "t1 = pd.merge(Student_Enrolment_Courses, Transcript_Contents, left_on='student_course_id', right_on='student_course_id')\nt2 = t1.groupby(['student_course_id']).size().rename('count')\nanswer = t2.sort_values(ascending=False).head(1).to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: You are trying to merge on object and int64 columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(0, 4)]", "py_exec_result": "   student_course_id  count\n0                  0      4", "gold_answer": [[4, 0]], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1", "query_toks": ["SELECT", "document_id", "FROM", "Paragraphs", "GROUP", "BY", "document_id", "ORDER", "BY", "count", "(", "*", ")", "ASC", "LIMIT", "1"], "query_toks_no_value": ["select", "document_id", "from", "paragraphs", "group", "by", "document_id", "order", "by", "count", "(", "*", ")", "asc", "limit", "value"], "question": "What is the document id with least number of paragraphs?", "question_toks": ["What", "is", "the", "document", "id", "with", "least", "number", "of", "paragraphs", "?"], "sql": {"from": {"table_units": [["table_unit", 3]], "conds": []}, "select": [false, [[0, [0, [0, 15, false], null]]]], "where": [], "groupBy": [[0, 15, false]], "having": [], "orderBy": ["asc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [[3]], "results": {"generated_sql": "SELECT T1.Document_ID FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID GROUP BY T1.Document_ID ORDER BY count(*) ASC LIMIT 1", "generated_py": "t1 = pd.merge(Documents, Paragraphs, left_on='document_id', right_on='document_id')\nt2 = t1.groupby('document_id').size().rename('count')\nt3 = t2.sort_values(ascending=True).head(1).to_frame().reset_index()\nanswer = t3['document_id']", "sql_error": null, "py_error": "ERROR: You are trying to merge on object and int64 columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(3,)]", "py_exec_result": "0    3\nName: document_id, dtype: int64", "gold_answer": [[3]], "gold_sql": "SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "query_toks": ["SELECT", "T2.Make", ",", "T1.Year", "FROM", "CARS_DATA", "AS", "T1", "JOIN", "CAR_NAMES", "AS", "T2", "ON", "T1.Id", "=", "T2.MakeId", "WHERE", "T1.Year", "=", "(", "SELECT", "min", "(", "YEAR", ")", "FROM", "CARS_DATA", ")", ";"], "query_toks_no_value": ["select", "t2", ".", "make", ",", "t1", ".", "year", "from", "cars_data", "as", "t1", "join", "car_names", "as", "t2", "on", "t1", ".", "id", "=", "t2", ".", "makeid", "where", "t1", ".", "year", "=", "(", "select", "min", "(", "year", ")", "from", "cars_data", ")"], "question": "What is the maker of the carr produced in the earliest year and what year was it?", "question_toks": ["What", "is", "the", "maker", "of", "the", "carr", "produced", "in", "the", "earliest", "year", "and", "what", "year", "was", "it", "?"], "sql": {"from": {"table_units": [["table_unit", 5], ["table_unit", 4]], "conds": [[false, 2, [0, [0, 16, false], null], [0, 13, false], null]]}, "select": [false, [[0, [0, [0, 15, false], null]], [0, [0, [0, 23, false], null]]]], "where": [[false, 2, [0, [0, 23, false], null], {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[2, [0, [0, 23, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [["chevrolet chevelle malibu", 1970], ["buick skylark 320", 1970], ["plymouth satellite", 1970], ["amc rebel sst", 1970], ["ford torino", 1970], ["ford galaxie 500", 1970], ["chevrolet impala", 1970], ["plymouth fury iii", 1970], ["pontiac catalina", 1970], ["amc ambassador dpl", 1970], ["citroen ds-21 pallas", 1970], ["chevrolet chevelle concours (sw)", 1970], ["ford torino (sw)", 1970], ["plymouth satellite (sw)", 1970], ["amc rebel sst (sw)", 1970], ["dodge challenger se", 1970], ["plymouth cuda 340", 1970], ["ford mustang boss 302", 1970], ["chevrolet monte carlo", 1970], ["buick estate wagon (sw)", 1970], ["toyota corona mark ii", 1970], ["plymouth duster", 1970], ["amc hornet", 1970], ["ford maverick", 1970], ["datsun pl510", 1970], ["volkswagen 1131 deluxe sedan", 1970], ["peugeot 504", 1970], ["audi 100 ls", 1970], ["saab 99e", 1970], ["bmw 2002", 1970], ["amc gremlin", 1970], ["ford f250", 1970], ["chevy c20", 1970], ["dodge d200", 1970], ["hi 1200d", 1970]], "results": {"generated_sql": "SELECT T1.Maker ,  T1.Year FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id  =  T2.MakeId JOIN model_list AS T3 ON T2.Model  =  T3.Model JOIN car_makers AS T4 ON T3.Maker  =  T4.Maker ORDER BY T1.Year ASC LIMIT 1", "generated_py": "t1 = cars_data.sort_values('year').head(1)\nt2 = pd.merge(t1, car_names, left_on='id', right_on='makeid')\nt3 = pd.merge(t2, car_makers, left_on='maker', right_on='id')\nanswer = t3[['fullname', 'year']]", "sql_error": "ERROR: no such column: T1.Maker", "py_error": "ERROR: 'maker'", "sql_exec_result": "None", "py_exec_result": "None", "gold_answer": [["chevrolet chevelle malibu", 1970], ["buick skylark 320", 1970], ["plymouth satellite", 1970], ["amc rebel sst", 1970], ["ford torino", 1970], ["ford galaxie 500", 1970], ["chevrolet impala", 1970], ["plymouth fury iii", 1970], ["pontiac catalina", 1970], ["amc ambassador dpl", 1970], ["citroen ds-21 pallas", 1970], ["chevrolet chevelle concours (sw)", 1970], ["ford torino (sw)", 1970], ["plymouth satellite (sw)", 1970], ["amc rebel sst (sw)", 1970], ["dodge challenger se", 1970], ["plymouth cuda 340", 1970], ["ford mustang boss 302", 1970], ["chevrolet monte carlo", 1970], ["buick estate wagon (sw)", 1970], ["toyota corona mark ii", 1970], ["plymouth duster", 1970], ["amc hornet", 1970], ["ford maverick", 1970], ["datsun pl510", 1970], ["volkswagen 1131 deluxe sedan", 1970], ["peugeot 504", 1970], ["audi 100 ls", 1970], ["saab 99e", 1970], ["bmw 2002", 1970], ["amc gremlin", 1970], ["ford f250", 1970], ["chevy c20", 1970], ["dodge d200", 1970], ["hi 1200d", 1970]], "gold_sql": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "world_1", "query": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  \"Africa\")", "query_toks": ["SELECT", "Name", "FROM", "country", "WHERE", "Continent", "=", "``", "Asia", "''", "AND", "population", ">", "(", "SELECT", "min", "(", "population", ")", "FROM", "country", "WHERE", "Continent", "=", "``", "Africa", "''", ")"], "query_toks_no_value": ["select", "name", "from", "country", "where", "continent", "=", "value", "and", "population", ">", "(", "select", "min", "(", "population", ")", "from", "country", "where", "continent", "=", "value", ")"], "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "question_toks": ["What", "are", "the", "Asian", "countries", "which", "have", "a", "population", "larger", "than", "that", "of", "any", "country", "in", "Africa", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [[false, 2, [0, [0, 10, false], null], "\"Asia\"", null], "and", [false, 3, [0, [0, 14, false], null], {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[2, [0, [0, 14, false], null]]]], "where": [[false, 2, [0, [0, 10, false], null], "\"Africa\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "answer": [["Afghanistan"], ["United Arab Emirates"], ["Armenia"], ["Azerbaijan"], ["Bangladesh"], ["Bahrain"], ["Brunei"], ["Bhutan"], ["China"], ["Cyprus"], ["Georgia"], ["Hong Kong"], ["Indonesia"], ["India"], ["Iran"], ["Iraq"], ["Israel"], ["Jordan"], ["Japan"], ["Kazakstan"], ["Kyrgyzstan"], ["Cambodia"], ["South Korea"], ["Kuwait"], ["Laos"], ["Lebanon"], ["Sri Lanka"], ["Macao"], ["Maldives"], ["Myanmar"], ["Mongolia"], ["Malaysia"], ["Nepal"], ["Oman"], ["Pakistan"], ["Philippines"], ["North Korea"], ["Palestine"], ["Qatar"], ["Saudi Arabia"], ["Singapore"], ["Syria"], ["Thailand"], ["Tajikistan"], ["Turkmenistan"], ["East Timor"], ["Turkey"], ["Taiwan"], ["Uzbekistan"], ["Vietnam"], ["Yemen"]], "results": {"generated_sql": "SELECT T1.Name FROM country AS T1 WHERE T1.Continent  =  'Asia' AND T1.Population  >  (SELECT max(T2.Population) FROM country AS T2 WHERE T2.Continent  =  'Africa')", "generated_py": "t1 = country[country['continent'] == 'Asia']\nt2 = country[country['continent'] == 'Africa']\nt3 = t1[t1['population'] > t2['population'].max()]\nanswer = t3['name']", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[('Bangladesh',), ('China',), ('Indonesia',), ('India',), ('Japan',), ('Pakistan',)]", "py_exec_result": "21     Bangladesh\n41          China\n98      Indonesia\n99          India\n109         Japan\n164      Pakistan\nName: name, dtype: object", "gold_answer": [["Afghanistan"], ["United Arab Emirates"], ["Armenia"], ["Azerbaijan"], ["Bangladesh"], ["Bahrain"], ["Brunei"], ["Bhutan"], ["China"], ["Cyprus"], ["Georgia"], ["Hong Kong"], ["Indonesia"], ["India"], ["Iran"], ["Iraq"], ["Israel"], ["Jordan"], ["Japan"], ["Kazakstan"], ["Kyrgyzstan"], ["Cambodia"], ["South Korea"], ["Kuwait"], ["Laos"], ["Lebanon"], ["Sri Lanka"], ["Macao"], ["Maldives"], ["Myanmar"], ["Mongolia"], ["Malaysia"], ["Nepal"], ["Oman"], ["Pakistan"], ["Philippines"], ["North Korea"], ["Palestine"], ["Qatar"], ["Saudi Arabia"], ["Singapore"], ["Syria"], ["Thailand"], ["Tajikistan"], ["Turkmenistan"], ["East Timor"], ["Turkey"], ["Taiwan"], ["Uzbekistan"], ["Vietnam"], ["Yemen"]], "gold_sql": "SELECT Name FROM country WHERE Continent  =  \"Asia\"  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  \"Africa\")", "table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "gold_py": null}}
{"db_id": "concert_singer", "query": "select max(capacity), average from stadium", "query_toks": ["select", "max", "(", "capacity", ")", ",", "average", "from", "stadium"], "query_toks_no_value": ["select", "max", "(", "capacity", ")", ",", "average", "from", "stadium"], "question": "What is the maximum capacity and the average of all stadiums ?", "question_toks": ["What", "is", "the", "maximum", "capacity", "and", "the", "average", "of", "all", "stadiums", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[1, [0, [0, 4, false], null]], [0, [0, [0, 7, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"stadium": ["Stadium_ID", "Location", "Name", "Capacity", "Highest", "Lowest", "Average"], "singer": ["Singer_ID", "Name", "Country", "Song_Name", "Song_release_year", "Age", "Is_male"], "concert": ["concert_ID", "concert_Name", "Theme", "Stadium_ID", "Year"], "singer_in_concert": ["concert_ID", "Singer_ID"]}, "answer": [[52500, 730]], "results": {"generated_sql": "SELECT max(capacity) ,  avg(capacity) FROM stadium", "generated_py": "t1 = stadium[['capacity', 'average']]\nanswer = t1.max()", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(52500, 10621.666666666666)]", "py_exec_result": "capacity    52500\naverage      2106\ndtype: int64", "gold_answer": [[52500, 730]], "gold_sql": "select max(capacity), average from stadium", "table_headers": {"stadium": ["Stadium_ID", "Location", "Name", "Capacity", "Highest", "Lowest", "Average"], "singer": ["Singer_ID", "Name", "Country", "Song_Name", "Song_release_year", "Age", "Is_male"], "concert": ["concert_ID", "concert_Name", "Theme", "Stadium_ID", "Year"], "singer_in_concert": ["concert_ID", "Singer_ID"]}, "gold_py": null}}
{"db_id": "poker_player", "query": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality", "query_toks": ["SELECT", "Nationality", ",", "COUNT", "(", "*", ")", "FROM", "people", "GROUP", "BY", "Nationality"], "query_toks_no_value": ["select", "nationality", ",", "count", "(", "*", ")", "from", "people", "group", "by", "nationality"], "question": "What are different nationalities of people and the corresponding number of people from each nation?", "question_toks": ["What", "are", "different", "nationalities", "of", "people", "and", "the", "corresponding", "number", "of", "people", "from", "each", "nation", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 8, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 8, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "answer": [["Bulgaria", 1], ["Russia", 6]], "results": {"generated_sql": "SELECT nationality ,  count(*) FROM people GROUP BY nationality", "generated_py": "answer = people.groupby('nationality').size().rename('count').to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[('Bulgaria', 1), ('Russia', 6)]", "py_exec_result": "  nationality  count\n0    Bulgaria      1\n1      Russia      6", "gold_answer": [["Bulgaria", 1], ["Russia", 6]], "gold_sql": "SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality", "table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "gold_py": null}}
{"db_id": "tvshow", "query": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "TV_Channel", "WHERE", "LANGUAGE", "=", "``", "English", "''", ";"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "tv_channel", "where", "language", "=", "value"], "question": "How many TV Channels use the English language?", "question_toks": ["How", "many", "TV", "Channels", "use", "the", "English", "language", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 2, [0, [0, 4, false], null], "\"English\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "answer": [[3]], "results": {"generated_sql": "SELECT count(*) FROM TV_Channel WHERE Language  =  'English'", "generated_py": "answer = pd.Series(TV_Channel[TV_Channel['language'] == 'English'].shape[0])", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(3,)]", "py_exec_result": "0    3\ndtype: int64", "gold_answer": [[3]], "gold_sql": "SELECT count(*) FROM TV_Channel WHERE LANGUAGE = \"English\";", "table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;", "query_toks": ["SELECT", "T1.FullName", ",", "T1.Id", ",", "count", "(", "*", ")", "FROM", "CAR_MAKERS", "AS", "T1", "JOIN", "MODEL_LIST", "AS", "T2", "ON", "T1.Id", "=", "T2.Maker", "GROUP", "BY", "T1.Id", ";"], "query_toks_no_value": ["select", "t1", ".", "fullname", ",", "t1", ".", "id", ",", "count", "(", "*", ")", "from", "car_makers", "as", "t1", "join", "model_list", "as", "t2", "on", "t1", ".", "id", "=", "t2", ".", "maker", "group", "by", "t1", ".", "id"], "question": "What is the full name of each car maker, along with its id and how many models it produces?", "question_toks": ["What", "is", "the", "full", "name", "of", "each", "car", "maker", ",", "along", "with", "its", "id", "and", "how", "many", "models", "it", "produces", "?"], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 3]], "conds": [[false, 2, [0, [0, 6, false], null], [0, 11, false], null]]}, "select": [false, [[0, [0, [0, 8, false], null]], [0, [0, [0, 6, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 6, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [["American Motor Company", 1, 1], ["Volkswagen", 2, 2], ["BMW", 3, 1], ["General Motors", 4, 5], ["Ford Motor Company", 5, 3], ["Chrysler", 6, 4], ["Citroen", 7, 1], ["Nissan Motors", 8, 2], ["Fiat", 9, 1], ["Honda", 11, 1], ["Mazda", 12, 1], ["Daimler Benz", 13, 2], ["Opel", 14, 1], ["Peugeaut", 15, 1], ["Renault", 16, 1], ["Saab", 17, 1], ["Subaru", 18, 1], ["Toyota", 19, 2], ["Triumph", 20, 1], ["Volvo", 21, 1], ["Kia Motors", 22, 1], ["Hyundai", 23, 1]], "results": {"generated_sql": "SELECT T1.id ,  T1.fullname ,  count(*) FROM car_makers AS T1 JOIN model_list AS T2 ON T1.id  =  T2.maker GROUP BY T1.id", "generated_py": "t1 = pd.merge(car_makers, model_list, left_on='id', right_on='maker')\nt2 = t1.groupby(['id', 'fullname']).size().rename('count')\nanswer = t2.to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(1, 'American Motor Company', 1), (2, 'Volkswagen', 2), (3, 'BMW', 1), (4, 'General Motors', 5), (5, 'Ford Motor Company', 3), (6, 'Chrysler', 4), (7, 'Citroen', 1), (8, 'Nissan Motors', 2), (9, 'Fiat', 1), (11, 'Honda', 1), (12, 'Mazda', 1), (13, 'Daimler Benz', 2), (14, 'Opel', 1), (15, 'Peugeaut', 1), (16, 'Renault', 1), (17, 'Saab', 1), (18, 'Subaru', 1), (19, 'Toyota', 2), (20, 'Triumph', 1), (21, 'Volvo', 1), (22, 'Kia Motors', 1), (23, 'Hyundai', 1)]", "py_exec_result": "    id                fullname  count\n0    1  American Motor Company      1\n1    2              Volkswagen      2\n2    3                     BMW      1\n3    4          General Motors      5\n4    5      Ford Motor Company      3\n5    6                Chrysler      4\n6    7                 Citroen      1\n7    8           Nissan Motors      2\n8    9                    Fiat      1\n9   11                   Honda      1\n10  12                   Mazda      1\n11  13            Daimler Benz      2\n12  14                    Opel      1\n13  15                Peugeaut      1\n14  16                 Renault      1\n15  17                    Saab      1\n16  18                  Subaru      1\n17  19                  Toyota      2\n18  20                 Triumph      1\n19  21                   Volvo      1\n20  22              Kia Motors      1\n21  23                 Hyundai      1", "gold_answer": [["American Motor Company", 1, 1], ["Volkswagen", 2, 2], ["BMW", 3, 1], ["General Motors", 4, 5], ["Ford Motor Company", 5, 3], ["Chrysler", 6, 4], ["Citroen", 7, 1], ["Nissan Motors", 8, 2], ["Fiat", 9, 1], ["Honda", 11, 1], ["Mazda", 12, 1], ["Daimler Benz", 13, 2], ["Opel", 14, 1], ["Peugeaut", 15, 1], ["Renault", 16, 1], ["Saab", 17, 1], ["Subaru", 18, 1], ["Toyota", 19, 2], ["Triumph", 20, 1], ["Volvo", 21, 1], ["Kia Motors", 22, 1], ["Hyundai", 23, 1]], "gold_sql": "SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "orchestra", "query": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003", "query_toks": ["SELECT", "Record_Company", "FROM", "orchestra", "WHERE", "Year_of_Founded", "<", "2003", "INTERSECT", "SELECT", "Record_Company", "FROM", "orchestra", "WHERE", "Year_of_Founded", ">", "2003"], "query_toks_no_value": ["select", "record_company", "from", "orchestra", "where", "year_of_founded", "<", "value", "intersect", "select", "record_company", "from", "orchestra", "where", "year_of_founded", ">", "value"], "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?", "question_toks": ["What", "are", "the", "record", "companies", "that", "are", "used", "by", "both", "orchestras", "founded", "before", "2003", "and", "those", "founded", "after", "2003", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [[false, 4, [0, [0, 10, false], null], 2003.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [[false, 3, [0, [0, 10, false], null], 2003.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "union": null, "except": null}, "db_table_headers": {"conductor": ["Conductor_ID", "Name", "Age", "Nationality", "Year_of_Work"], "orchestra": ["Orchestra_ID", "Orchestra", "Conductor_ID", "Record_Company", "Year_of_Founded", "Major_Record_Format"], "performance": ["Performance_ID", "Orchestra_ID", "Type", "Date", "Official_ratings_(millions)", "Weekly_rank", "Share"], "show": ["Show_ID", "Performance_ID", "If_first_show", "Result", "Attendance"]}, "answer": [["Decca Records"]], "results": {"generated_sql": "SELECT DISTINCT T1.record_company FROM orchestra AS T1 JOIN orchestra AS T2 ON T1.record_company  =  T2.record_company WHERE T1.year_of_founded  <  2003 AND T2.year_of_founded  >  2003", "generated_py": "t1 = orchestra[orchestra['year_of_founded'] < 2003]\nt2 = orchestra[orchestra['year_of_founded'] > 2003]\nt3 = pd.concat([t1, t2])\nanswer = t3['record_company'].unique()", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[('Decca Records',)]", "py_exec_result": "['Kultur' 'Decca Records' 'Delos Records' 'Columbia Masterworks' 'Philips'\n 'Philips Classics Records' 'Koch Records / Naxos Records' 'EMI' 'RCA']", "gold_answer": [["Decca Records"]], "gold_sql": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003", "table_headers": {"conductor": ["Conductor_ID", "Name", "Age", "Nationality", "Year_of_Work"], "orchestra": ["Orchestra_ID", "Orchestra", "Conductor_ID", "Record_Company", "Year_of_Founded", "Major_Record_Format"], "performance": ["Performance_ID", "Orchestra_ID", "Type", "Date", "Official_ratings_(millions)", "Weekly_rank", "Share"], "show": ["Show_ID", "Performance_ID", "If_first_show", "Result", "Attendance"]}, "gold_py": null}}
{"db_id": "student_transcripts_tracking", "query": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "Departments", "AS", "T1", "JOIN", "Degree_Programs", "AS", "T2", "ON", "T1.department_id", "=", "T2.department_id", "WHERE", "T1.department_name", "=", "'engineer", "'"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "departments", "as", "t1", "join", "degree_programs", "as", "t2", "on", "t1", ".", "department_id", "=", "t2", ".", "department_id", "where", "t1", ".", "department_name", "=", "value"], "question": "How many degrees does the engineering department have?", "question_toks": ["How", "many", "degrees", "does", "the", "engineering", "department", "have", "?"], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 3]], "conds": [[false, 2, [0, [0, 14, false], null], [0, 19, false], null]]}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 2, [0, [0, 15, false], null], "\"engineer\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "answer": [[0]], "results": {"generated_sql": "SELECT count(*) FROM degree_programs WHERE department_id  =  (SELECT department_id FROM departments WHERE department_name  =  'engineering')", "generated_py": "t1 = pd.merge(Degree_Programs, Departments, left_on='department_id', right_on='department_id')\nt2 = t1[t1['department_name'] == 'Engineering']\nanswer = pd.Series(t2.shape[0])", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(0,)]", "py_exec_result": "0    0\ndtype: int64", "gold_answer": [[0]], "gold_sql": "SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer'", "table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "query_toks": ["SELECT", "COUNT", "(", "*", ")", "FROM", "CARS_DATA", "WHERE", "Accelerate", ">", "(", "SELECT", "Accelerate", "FROM", "CARS_DATA", "ORDER", "BY", "Horsepower", "DESC", "LIMIT", "1", ")", ";"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "cars_data", "where", "accelerate", ">", "(", "select", "accelerate", "from", "cars_data", "order", "by", "horsepower", "desc", "limit", "value", ")"], "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "question_toks": ["What", "is", "the", "number", "of", "cars", "with", "a", "greater", "accelerate", "than", "the", "one", "with", "the", "most", "horsepower", "?"], "sql": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 3, [0, [0, 22, false], null], {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[0, [0, [0, 22, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 20, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [[39]], "results": {"generated_sql": "SELECT count(*) FROM cars_data WHERE accelerate  >  (SELECT max(horsepower) FROM cars_data)", "generated_py": "t1 = cars_data.sort_values('horsepower', ascending=False).head(1)\nanswer = pd.Series(cars_data[cars_data['accelerate'] > t1['accelerate'].iloc[0]].shape[0])", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(0,)]", "py_exec_result": "0    174\ndtype: int64", "gold_answer": [[39]], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "tvshow", "query": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "Cartoon", "WHERE", "Written_by", "=", "``", "Joseph", "Kuhr", "''", ";"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "cartoon", "where", "written_by", "=", "value"], "question": "How many cartoons were written by \"Joseph Kuhr\"?", "question_toks": ["How", "many", "cartoons", "were", "written", "by", "``", "Joseph", "Kuhr", "''", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [[false, 2, [0, [0, 22, false], null], "\"Joseph Kuhr\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "answer": [[2]], "results": {"generated_sql": "SELECT count(*) FROM cartoon WHERE written_by  =  'Joseph Kuhr'", "generated_py": "answer = pd.Series(Cartoon[Cartoon['written_by'] == 'Joseph Kuhr'].shape[0])", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(2,)]", "py_exec_result": "0    2\ndtype: int64", "gold_answer": [[2]], "gold_sql": "SELECT count(*) FROM Cartoon WHERE Written_by = \"Joseph Kuhr\";", "table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "gold_py": null}}
{"db_id": "network_1", "query": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id", "query_toks": ["SELECT", "student_id", ",", "count", "(", "*", ")", "FROM", "Likes", "GROUP", "BY", "student_id"], "query_toks_no_value": ["select", "student_id", ",", "count", "(", "*", ")", "from", "likes", "group", "by", "student_id"], "question": "How many likes correspond to each student id?", "question_toks": ["How", "many", "likes", "correspond", "to", "each", "student", "id", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 6, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 6, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Highschooler": ["ID", "name", "grade"], "Friend": ["student_id", "friend_id"], "Likes": ["student_id", "liked_id"]}, "answer": [[1025, 1], [1247, 1], [1316, 1], [1501, 1], [1641, 1], [1689, 1], [1709, 1], [1782, 1], [1911, 1], [1934, 1]], "results": {"generated_sql": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id", "generated_py": "t1 = Likes.groupby('student_id').size().rename('count')\nanswer = t1.to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(1025, 1), (1247, 1), (1316, 1), (1501, 1), (1641, 1), (1689, 1), (1709, 1), (1782, 1), (1911, 1), (1934, 1)]", "py_exec_result": "   student_id  count\n0        1025      1\n1        1247      1\n2        1316      1\n3        1501      1\n4        1641      1\n5        1689      1\n6        1709      1\n7        1782      1\n8        1911      1\n9        1934      1", "gold_answer": [[1025, 1], [1247, 1], [1316, 1], [1501, 1], [1641, 1], [1689, 1], [1709, 1], [1782, 1], [1911, 1], [1934, 1]], "gold_sql": "SELECT student_id ,  count(*) FROM Likes GROUP BY student_id", "table_headers": {"Highschooler": ["ID", "name", "grade"], "Friend": ["student_id", "friend_id"], "Likes": ["student_id", "liked_id"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1", "query_toks": ["SELECT", "T1.document_id", ",", "T2.document_name", "FROM", "Paragraphs", "AS", "T1", "JOIN", "Documents", "AS", "T2", "ON", "T1.document_id", "=", "T2.document_id", "GROUP", "BY", "T1.document_id", "ORDER", "BY", "count", "(", "*", ")", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "t1", ".", "document_id", ",", "t2", ".", "document_name", "from", "paragraphs", "as", "t1", "join", "documents", "as", "t2", "on", "t1", ".", "document_id", "=", "t2", ".", "document_id", "group", "by", "t1", ".", "document_id", "order", "by", "count", "(", "*", ")", "desc", "limit", "value"], "question": "Return the id and name of the document with the most paragraphs.", "question_toks": ["Return", "the", "id", "and", "name", "of", "the", "document", "with", "the", "most", "paragraphs", "."], "sql": {"from": {"table_units": [["table_unit", 3], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 15, false], null], [0, 9, false], null]]}, "select": [false, [[0, [0, [0, 15, false], null]], [0, [0, [0, 11, false], null]]]], "where": [], "groupBy": [[0, 15, false]], "having": [], "orderBy": ["desc", [[0, [3, 0, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [[2394, "Customer reviews"]], "results": {"generated_sql": "SELECT T1.Document_ID ,  T1.Document_Name FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID  =  T2.Document_ID GROUP BY T1.Document_ID ORDER BY count(*) DESC LIMIT 1", "generated_py": "t1 = pd.merge(Documents, Paragraphs, on='document_id')\nt2 = t1.groupby('document_id').size().rename('count')\nt3 = t2.sort_values(ascending=False).head(1).to_frame().reset_index()\nt4 = pd.merge(t3, Documents, on='document_id')\nanswer = t4[['document_id', 'document_name']]", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(2394, 'Customer reviews')]", "py_exec_result": "   document_id     document_name\n0         2394  Customer reviews", "gold_answer": [[2394, "Customer reviews"]], "gold_sql": "SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "battle_death", "query": "SELECT name ,  date FROM battle", "query_toks": ["SELECT", "name", ",", "date", "FROM", "battle"], "query_toks_no_value": ["select", "name", ",", "date", "from", "battle"], "question": "List the name, date and result of each battle.", "question_toks": ["List", "the", "name", ",", "date", "and", "result", "of", "each", "battle", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 2, false], null]], [0, [0, [0, 3, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"battle": ["id", "name", "date", "bulgarian_commander", "latin_commander", "result"], "ship": ["lost_in_battle", "id", "name", "tonnage", "ship_type", "location", "disposition_of_ship"], "death": ["caused_by_ship_id", "id", "note", "killed", "injured"]}, "answer": [["Battle of Adrianople", "14 April 1205"], ["Battle of Serres", "June 1205"], ["Battle of Rusion", "31 January 1206"], ["Battle of Rodosto", "February 1206"], ["Battle of Messinopolis", "4 September 1207"], ["Battle of Boruy", "June 1205"], ["Battle of Philippopolis", "31 June 1208"], ["Siege of Constantinople", "1235"]], "results": {"generated_sql": "SELECT name ,  date ,  result FROM battle", "generated_py": "answer = battle[['name', 'date', 'result']]", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[('Battle of Adrianople', '14 April 1205', 'Bulgarian victory'), ('Battle of Serres', 'June 1205', 'Bulgarian victory'), ('Battle of Rusion', '31 January 1206', 'Bulgarian victory'), ('Battle of Rodosto', 'February 1206', 'Bulgarian victory'), ('Battle of Messinopolis', '4 September 1207', 'Bulgarian victory'), ('Battle of Boruy', 'June 1205', 'Bulgarian victory'), ('Battle of Philippopolis', '31 June 1208', 'Latin victory'), ('Siege of Constantinople', '1235', 'Two Year Truce')]", "py_exec_result": "                      name              date             result\n0     Battle of Adrianople     14 April 1205  Bulgarian victory\n1         Battle of Serres         June 1205  Bulgarian victory\n2         Battle of Rusion   31 January 1206  Bulgarian victory\n3        Battle of Rodosto     February 1206  Bulgarian victory\n4   Battle of Messinopolis  4 September 1207  Bulgarian victory\n5          Battle of Boruy         June 1205  Bulgarian victory\n6  Battle of Philippopolis      31 June 1208      Latin victory\n7  Siege of Constantinople              1235     Two Year Truce", "gold_answer": [["Battle of Adrianople", "14 April 1205"], ["Battle of Serres", "June 1205"], ["Battle of Rusion", "31 January 1206"], ["Battle of Rodosto", "February 1206"], ["Battle of Messinopolis", "4 September 1207"], ["Battle of Boruy", "June 1205"], ["Battle of Philippopolis", "31 June 1208"], ["Siege of Constantinople", "1235"]], "gold_sql": "SELECT name ,  date FROM battle", "table_headers": {"battle": ["id", "name", "date", "bulgarian_commander", "latin_commander", "result"], "ship": ["lost_in_battle", "id", "name", "tonnage", "ship_type", "location", "disposition_of_ship"], "death": ["caused_by_ship_id", "id", "note", "killed", "injured"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;", "query_toks": ["SELECT", "avg", "(", "Weight", ")", ",", "YEAR", "FROM", "CARS_DATA", "GROUP", "BY", "YEAR", ";"], "query_toks_no_value": ["select", "avg", "(", "weight", ")", ",", "year", "from", "cars_data", "group", "by", "year"], "question": "What is the average weight and year for each year?", "question_toks": ["What", "is", "the", "average", "weight", "and", "year", "for", "each", "year", "?"], "sql": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[5, [0, [0, 21, false], null]], [0, [0, [0, 23, false], null]]]], "where": [], "groupBy": [[0, 23, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [[3441.3142857142857, 1970], [2960.344827586207, 1971], [3237.714285714286, 1972], [3419.025, 1973], [2877.925925925926, 1974], [3176.8, 1975], [3078.735294117647, 1976], [2997.3571428571427, 1977], [2861.8055555555557, 1978], [3055.344827586207, 1979], [2436.655172413793, 1980], [2532.1666666666665, 1981], [2453.548387096774, 1982]], "results": {"generated_sql": "SELECT year ,  avg(weight) ,  avg(year) FROM cars_data GROUP BY year", "generated_py": "t1 = pd.merge(cars_data, car_names, left_on='id', right_on='makeid')\nt2 = t1.groupby('year').agg({'weight': 'mean', 'year': 'mean'})\nanswer = t2", "sql_error": null, "py_error": "ERROR: 'maker'", "sql_exec_result": "[(1970, 3441.3142857142857, 1970.0), (1971, 2960.344827586207, 1971.0), (1972, 3237.714285714286, 1972.0), (1973, 3419.025, 1973.0), (1974, 2877.925925925926, 1974.0), (1975, 3176.8, 1975.0), (1976, 3078.735294117647, 1976.0), (1977, 2997.3571428571427, 1977.0), (1978, 2861.8055555555557, 1978.0), (1979, 3055.344827586207, 1979.0), (1980, 2436.655172413793, 1980.0), (1981, 2532.1666666666665, 1981.0), (1982, 2453.548387096774, 1982.0)]", "py_exec_result": "           weight    year\nyear                     \n1970  3441.314286  1970.0\n1971  2960.344828  1971.0\n1972  3237.714286  1972.0\n1973  3419.025000  1973.0\n1974  2877.925926  1974.0\n1975  3176.800000  1975.0\n1976  3078.735294  1976.0\n1977  2997.357143  1977.0\n1978  2861.805556  1978.0\n1979  3055.344828  1979.0\n1980  2436.655172  1980.0\n1981  2532.166667  1981.0\n1982  2453.548387  1982.0", "gold_answer": [[3441.3142857142857, 1970], [2960.344827586207, 1971], [3237.714285714286, 1972], [3419.025, 1973], [2877.925925925926, 1974], [3176.8, 1975], [3078.735294117647, 1976], [2997.3571428571427, 1977], [2861.8055555555557, 1978], [3055.344827586207, 1979], [2436.655172413793, 1980], [2532.1666666666665, 1981], [2453.548387096774, 1982]], "gold_sql": "SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "query_toks": ["SELECT", "T1.model", "FROM", "CAR_NAMES", "AS", "T1", "JOIN", "CARS_DATA", "AS", "T2", "ON", "T1.MakeId", "=", "T2.Id", "WHERE", "T2.Weight", "<", "(", "SELECT", "avg", "(", "Weight", ")", "FROM", "CARS_DATA", ")"], "query_toks_no_value": ["select", "t1", ".", "model", "from", "car_names", "as", "t1", "join", "cars_data", "as", "t2", "on", "t1", ".", "makeid", "=", "t2", ".", "id", "where", "t2", ".", "weight", "<", "(", "select", "avg", "(", "weight", ")", "from", "cars_data", ")"], "question": "Find the model of the car whose weight is below the average weight.", "question_toks": ["Find", "the", "model", "of", "the", "car", "whose", "weight", "is", "below", "the", "average", "weight", "."], "sql": {"from": {"table_units": [["table_unit", 4], ["table_unit", 5]], "conds": [[false, 2, [0, [0, 13, false], null], [0, 16, false], null]]}, "select": [false, [[0, [0, [0, 14, false], null]]]], "where": [[false, 4, [0, [0, 21, false], null], {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[5, [0, [0, 21, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [["toyota"], ["plymouth"], ["amc"], ["ford"], ["datsun"], ["volkswagen"], ["peugeot"], ["audi"], ["saab"], ["bmw"], ["amc"], ["datsun"], ["chevrolet"], ["toyota"], ["ford"], ["volkswagen"], ["amc"], ["amc"], ["chevrolet"], ["mercury"], ["opel"], ["peugeot"], ["fiat"], ["toyota"], ["datsun"], ["volkswagen"], ["plymouth"], ["toyota"], ["dodge"], ["volkswagen"], ["chevrolet"], ["ford"], ["mazda"], ["volvo"], ["volkswagen"], ["peugeot"], ["renault"], ["ford"], ["datsun"], ["toyota"], ["dodge"], ["toyota"], ["amc"], ["plymouth"], ["volkswagen"], ["amc"], ["toyota"], ["chevrolet"], ["datsun"], ["mazda"], ["ford"], ["mercury"], ["fiat"], ["fiat"], ["opel"], ["audi"], ["volvo"], ["saab"], ["toyota"], ["ford"], ["amc"], ["datsun"], ["ford"], ["toyota"], ["chevrolet"], ["audi"], ["volkswagen"], ["opel"], ["toyota"], ["datsun"], ["dodge"], ["fiat"], ["fiat"], ["honda"], ["subaru"], ["fiat"], ["toyota"], ["ford"], ["amc"], ["pontiac"], ["toyota"], ["volkswagen"], ["datsun"], ["volkswagen"], ["audi"], ["peugeot"], ["volvo"], ["saab"], ["honda"], ["fiat"], ["opel"], ["capri"], ["dodge"], ["renault"], ["chevrolet"], ["chevrolet"], ["volkswagen"], ["honda"], ["volkswagen"], ["datsun"], ["toyota"], ["ford"], ["toyota"], ["honda"], ["buick"], ["renault"], ["plymouth"], ["datsun"], ["volkswagen"], ["pontiac"], ["toyota"], ["ford"], ["chevrolet"], ["dodge"], ["subaru"], ["volkswagen"], ["datsun"], ["bmw"], ["mazda"], ["volkswagen"], ["ford"], ["mazda"], ["datsun"], ["honda"], ["ford"], ["ford"], ["chevrolet"], ["toyota"], ["datsun"], ["dodge"], ["toyota"], ["plymouth"], ["oldsmobile"], ["datsun"], ["audi"], ["saab"], ["volkswagen"], ["honda"], ["ford"], ["volkswagen"], ["mazda"], ["dodge"], ["amc"], ["plymouth"], ["plymouth"], ["datsun"], ["fiat"], ["buick"], ["chevrolet"], ["oldsmobile"], ["pontiac"], ["volkswagen"], ["toyota"], ["chevrolet"], ["datsun"], ["chevrolet"], ["ford"], ["audi"], ["toyota"], ["mazda"], ["datsun"], ["toyota"], ["mazda"], ["dodge"], ["datsun"], ["volkswagen"], ["volkswagen"], ["audi"], ["honda"], ["renault"], ["subaru"], [" volkswagen"], ["datsun"], ["mazda"], ["triumph"], ["ford"], ["honda"], ["plymouth"], ["buick"], ["dodge"], ["chevrolet"], ["plymouth"], ["toyota"], ["plymouth"], ["honda"], ["subaru"], ["datsun"], ["toyota"], ["mazda"], ["plymouth"], ["ford"], ["ford"], ["volkswagen"], ["renault"], ["honda"], ["toyota"], ["datsun"], ["mazda"], ["saab"], ["toyota"], ["datsun"], ["chevrolet"], ["chevrolet"], ["chevrolet"], ["pontiac"], ["dodge"], ["pontiac"], ["ford"], ["volkswagen"], ["mazda"], ["mazda"], ["plymouth"], ["mercury"], ["nissan"], ["honda"], ["toyota"], ["honda"], ["honda"], ["datsun"], ["buick"], ["chrysler"], ["ford"], ["toyota"], ["dodge"], ["chevrolet"], ["ford"], ["volkswagen"], ["dodge"], ["ford"], ["chevrolet"]], "results": {"generated_sql": "SELECT model FROM car_names WHERE weight  <  (SELECT avg(weight) FROM cars_data)", "generated_py": "t1 = cars_data.groupby('model').mean()\nt2 = t1[t1['weight'] < t1['weight'].mean()]\nanswer = t2.index", "sql_error": "ERROR: no such column: weight", "py_error": "ERROR: 'model'", "sql_exec_result": "None", "py_exec_result": "None", "gold_answer": [["toyota"], ["plymouth"], ["amc"], ["ford"], ["datsun"], ["volkswagen"], ["peugeot"], ["audi"], ["saab"], ["bmw"], ["amc"], ["datsun"], ["chevrolet"], ["toyota"], ["ford"], ["volkswagen"], ["amc"], ["amc"], ["chevrolet"], ["mercury"], ["opel"], ["peugeot"], ["fiat"], ["toyota"], ["datsun"], ["volkswagen"], ["plymouth"], ["toyota"], ["dodge"], ["volkswagen"], ["chevrolet"], ["ford"], ["mazda"], ["volvo"], ["volkswagen"], ["peugeot"], ["renault"], ["ford"], ["datsun"], ["toyota"], ["dodge"], ["toyota"], ["amc"], ["plymouth"], ["volkswagen"], ["amc"], ["toyota"], ["chevrolet"], ["datsun"], ["mazda"], ["ford"], ["mercury"], ["fiat"], ["fiat"], ["opel"], ["audi"], ["volvo"], ["saab"], ["toyota"], ["ford"], ["amc"], ["datsun"], ["ford"], ["toyota"], ["chevrolet"], ["audi"], ["volkswagen"], ["opel"], ["toyota"], ["datsun"], ["dodge"], ["fiat"], ["fiat"], ["honda"], ["subaru"], ["fiat"], ["toyota"], ["ford"], ["amc"], ["pontiac"], ["toyota"], ["volkswagen"], ["datsun"], ["volkswagen"], ["audi"], ["peugeot"], ["volvo"], ["saab"], ["honda"], ["fiat"], ["opel"], ["capri"], ["dodge"], ["renault"], ["chevrolet"], ["chevrolet"], ["volkswagen"], ["honda"], ["volkswagen"], ["datsun"], ["toyota"], ["ford"], ["toyota"], ["honda"], ["buick"], ["renault"], ["plymouth"], ["datsun"], ["volkswagen"], ["pontiac"], ["toyota"], ["ford"], ["chevrolet"], ["dodge"], ["subaru"], ["volkswagen"], ["datsun"], ["bmw"], ["mazda"], ["volkswagen"], ["ford"], ["mazda"], ["datsun"], ["honda"], ["ford"], ["ford"], ["chevrolet"], ["toyota"], ["datsun"], ["dodge"], ["toyota"], ["plymouth"], ["oldsmobile"], ["datsun"], ["audi"], ["saab"], ["volkswagen"], ["honda"], ["ford"], ["volkswagen"], ["mazda"], ["dodge"], ["amc"], ["plymouth"], ["plymouth"], ["datsun"], ["fiat"], ["buick"], ["chevrolet"], ["oldsmobile"], ["pontiac"], ["volkswagen"], ["toyota"], ["chevrolet"], ["datsun"], ["chevrolet"], ["ford"], ["audi"], ["toyota"], ["mazda"], ["datsun"], ["toyota"], ["mazda"], ["dodge"], ["datsun"], ["volkswagen"], ["volkswagen"], ["audi"], ["honda"], ["renault"], ["subaru"], [" volkswagen"], ["datsun"], ["mazda"], ["triumph"], ["ford"], ["honda"], ["plymouth"], ["buick"], ["dodge"], ["chevrolet"], ["plymouth"], ["toyota"], ["plymouth"], ["honda"], ["subaru"], ["datsun"], ["toyota"], ["mazda"], ["plymouth"], ["ford"], ["ford"], ["volkswagen"], ["renault"], ["honda"], ["toyota"], ["datsun"], ["mazda"], ["saab"], ["toyota"], ["datsun"], ["chevrolet"], ["chevrolet"], ["chevrolet"], ["pontiac"], ["dodge"], ["pontiac"], ["ford"], ["volkswagen"], ["mazda"], ["mazda"], ["plymouth"], ["mercury"], ["nissan"], ["honda"], ["toyota"], ["honda"], ["honda"], ["datsun"], ["buick"], ["chrysler"], ["ford"], ["toyota"], ["dodge"], ["chevrolet"], ["ford"], ["volkswagen"], ["dodge"], ["ford"], ["chevrolet"]], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "employee_hire_evaluation", "query": "SELECT * FROM hiring", "query_toks": ["SELECT", "*", "FROM", "hiring"], "query_toks_no_value": ["select", "*", "from", "hiring"], "question": "What is all the information about hiring?", "question_toks": ["What", "is", "all", "the", "information", "about", "hiring", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"employee": ["Employee_ID", "Name", "Age", "City"], "shop": ["Shop_ID", "Name", "Location", "District", "Number_products", "Manager_name"], "hiring": ["Shop_ID", "Employee_ID", "Start_from", "Is_full_time"], "evaluation": ["Employee_ID", "Year_awarded", "Bonus"]}, "answer": [[1, 1, "2009", "T"], [1, 2, "2003", "T"], [8, 3, "2011", "F"], [4, 4, "2012", "T"], [5, 5, "2013", "T"], [2, 6, "2010", "F"], [6, 7, "2008", "T"]], "results": {"generated_sql": "SELECT * FROM hiring", "generated_py": "answer = hiring", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[(1, 1, '2009', 'T'), (1, 2, '2003', 'T'), (8, 3, '2011', 'F'), (4, 4, '2012', 'T'), (5, 5, '2013', 'T'), (2, 6, '2010', 'F'), (6, 7, '2008', 'T')]", "py_exec_result": "   shop_id  employee_id start_from is_full_time\n0        1            1       2009            T\n1        1            2       2003            T\n2        8            3       2011            F\n3        4            4       2012            T\n4        5            5       2013            T\n5        2            6       2010            F\n6        6            7       2008            T", "gold_answer": [[1, 1, "2009", "T"], [1, 2, "2003", "T"], [8, 3, "2011", "F"], [4, 4, "2012", "T"], [5, 5, "2013", "T"], [2, 6, "2010", "F"], [6, 7, "2008", "T"]], "gold_sql": "SELECT * FROM hiring", "table_headers": {"employee": ["Employee_ID", "Name", "Age", "City"], "shop": ["Shop_ID", "Name", "Location", "District", "Number_products", "Manager_name"], "hiring": ["Shop_ID", "Employee_ID", "Start_from", "Is_full_time"], "evaluation": ["Employee_ID", "Year_awarded", "Bonus"]}, "gold_py": null}}
{"db_id": "voter_1", "query": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'", "query_toks": ["SELECT", "T2.created", ",", "T2.state", ",", "T2.phone_number", "FROM", "contestants", "AS", "T1", "JOIN", "votes", "AS", "T2", "ON", "T1.contestant_number", "=", "T2.contestant_number", "WHERE", "T1.contestant_name", "=", "'Tabatha", "Gehling", "'"], "query_toks_no_value": ["select", "t2", ".", "created", ",", "t2", ".", "state", ",", "t2", ".", "phone_number", "from", "contestants", "as", "t1", "join", "votes", "as", "t2", "on", "t1", ".", "contestant_number", "=", "t2", ".", "contestant_number", "where", "t1", ".", "contestant_name", "=", "value"], "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?", "question_toks": ["What", "are", "the", "create", "dates", ",", "states", ",", "and", "phone", "numbers", "of", "the", "votes", "that", "were", "for", "the", "contestant", "named", "'Tabatha", "Gehling", "'", "?"], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 3, false], null], [0, 8, false], null]]}, "select": [false, [[0, [0, [0, 9, false], null]], [0, [0, [0, 7, false], null]], [0, [0, [0, 6, false], null]]]], "where": [[false, 2, [0, [0, 4, false], null], "\"Tabatha Gehling\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"AREA_CODE_STATE": ["area_code", "state"], "CONTESTANTS": ["contestant_number", "contestant_name"], "VOTES": ["vote_id", "phone_number", "state", "contestant_number", "created"]}, "answer": [["2018-03-09 19:03:21", "NY", 7182887233]], "results": {"generated_sql": "SELECT created ,  state ,  phone_number FROM votes WHERE contestant_number  =  (SELECT contestant_number FROM contestants WHERE contestant_name  =  'Tabatha Gehling')", "generated_py": "t1 = pd.merge(VOTES, CONTESTANTS, left_on='contestant_number', right_on='contestant_number')\nanswer = t1[t1['contestant_name'] == 'Tabatha Gehling'][['created', 'state', 'phone_number']]", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[('2018-03-09 19:03:21', 'NY', 7182887233)]", "py_exec_result": "               created state  phone_number\n0  2018-03-09 19:03:21    NY    7182887233", "gold_answer": [["2018-03-09 19:03:21", "NY", 7182887233]], "gold_sql": "SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'", "table_headers": {"AREA_CODE_STATE": ["area_code", "state"], "CONTESTANTS": ["contestant_number", "contestant_name"], "VOTES": ["vote_id", "phone_number", "state", "contestant_number", "created"]}, "gold_py": null}}
{"db_id": "student_transcripts_tracking", "query": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "query_toks": ["SELECT", "T1.last_name", "FROM", "Students", "AS", "T1", "JOIN", "Addresses", "AS", "T2", "ON", "T1.current_address_id", "=", "T2.address_id", "WHERE", "T2.state_province_county", "=", "'NorthCarolina", "'", "EXCEPT", "SELECT", "DISTINCT", "T3.last_name", "FROM", "Students", "AS", "T3", "JOIN", "Student_Enrolment", "AS", "T4", "ON", "T3.student_id", "=", "T4.student_id"], "query_toks_no_value": ["select", "t1", ".", "last_name", "from", "students", "as", "t1", "join", "addresses", "as", "t2", "on", "t1", ".", "current_address_id", "=", "t2", ".", "address_id", "where", "t2", ".", "state_province_county", "=", "value", "except", "select", "distinct", "t3", ".", "last_name", "from", "students", "as", "t3", "join", "student_enrolment", "as", "t4", "on", "t3", ".", "student_id", "=", "t4", ".", "student_id"], "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.", "question_toks": ["Find", "the", "last", "name", "of", "the", "students", "who", "currently", "live", "in", "the", "state", "of", "North", "Carolina", "but", "have", "not", "registered", "in", "any", "degree", "program", "."], "sql": {"from": {"table_units": [["table_unit", 6], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 33, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 37, false], null]]]], "where": [[false, 2, [0, [0, 7, false], null], "\"NorthCarolina\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": {"from": {"table_units": [["table_unit", 6], ["table_unit", 7]], "conds": [[false, 2, [0, [0, 32, false], null], [0, 47, false], null]]}, "select": [true, [[0, [0, [0, 37, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "answer": [["Gleichner"], ["Weimann"]], "results": {"generated_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'North Carolina' AND T1.student_id  NOT  IN (SELECT student_id FROM Student_Enrolment)", "generated_py": "t1 = pd.merge(Addresses, Students, left_on='address_id', right_on='current_address_id')\nt2 = pd.merge(t1, Student_Enrolment, left_on='student_id', right_on='student_id')\nt3 = t1[t1['state_province_county'] == 'North Carolina']\nt4 = t3[t3['student_id'].isin(t2['student_id']) == False]\nanswer = t4['last_name']", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[]", "py_exec_result": "Series([], Name: last_name, dtype: object)", "gold_answer": [["Gleichner"], ["Weimann"]], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "gold_py": null}}
{"db_id": "student_transcripts_tracking", "query": "SELECT count(*) FROM Courses", "query_toks": ["SELECT", "count", "(", "*", ")", "FROM", "Courses"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "courses"], "question": "How many courses are there?", "question_toks": ["How", "many", "courses", "are", "there", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "answer": [[15]], "results": {"generated_sql": "SELECT count(*) FROM courses", "generated_py": "answer = pd.Series(Courses.shape[0])", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[(15,)]", "py_exec_result": "0    15\ndtype: int64", "gold_answer": [[15]], "gold_sql": "SELECT count(*) FROM Courses", "table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "gold_py": null}}
{"db_id": "voter_1", "query": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'", "query_toks": ["SELECT", "contestant_name", "FROM", "contestants", "WHERE", "contestant_name", "!", "=", "'Jessie", "Alloway", "'"], "query_toks_no_value": ["select", "contestant_name", "from", "contestants", "where", "contestant_name", "!", "=", "value"], "question": "What are the names of the contestants whose names are not 'Jessie Alloway'", "question_toks": ["What", "are", "the", "names", "of", "the", "contestants", "whose", "names", "are", "not", "'Jessie", "Alloway", "'"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 4, false], null]]]], "where": [[false, 7, [0, [0, 4, false], null], "\"Jessie Alloway\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"AREA_CODE_STATE": ["area_code", "state"], "CONTESTANTS": ["contestant_number", "contestant_name"], "VOTES": ["vote_id", "phone_number", "state", "contestant_number", "created"]}, "answer": [["Edwina Burnam"], ["Tabatha Gehling"], ["Kelly Clauss"], ["Alana Bregman"], ["Jessie Eichman"], ["Allie Rogalski"], ["Nita Coster"], ["Kurt Walser"], ["Ericka Dieter"], ["Loraine NygrenTania Mattioli"]], "results": {"generated_sql": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'", "generated_py": "answer = CONTESTANTS[CONTESTANTS['contestant_name'] != 'Jessie Alloway']['contestant_name']", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[('Edwina Burnam',), ('Tabatha Gehling',), ('Kelly Clauss',), ('Alana Bregman',), ('Jessie Eichman',), ('Allie Rogalski',), ('Nita Coster',), ('Kurt Walser',), ('Ericka Dieter',), ('Loraine NygrenTania Mattioli',)]", "py_exec_result": "0                    Edwina Burnam\n1                  Tabatha Gehling\n2                     Kelly Clauss\n4                    Alana Bregman\n5                   Jessie Eichman\n6                   Allie Rogalski\n7                      Nita Coster\n8                      Kurt Walser\n9                    Ericka Dieter\n10    Loraine NygrenTania Mattioli\nName: contestant_name, dtype: object", "gold_answer": [["Edwina Burnam"], ["Tabatha Gehling"], ["Kelly Clauss"], ["Alana Bregman"], ["Jessie Eichman"], ["Allie Rogalski"], ["Nita Coster"], ["Kurt Walser"], ["Ericka Dieter"], ["Loraine NygrenTania Mattioli"]], "gold_sql": "SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway'", "table_headers": {"AREA_CODE_STATE": ["area_code", "state"], "CONTESTANTS": ["contestant_number", "contestant_name"], "VOTES": ["vote_id", "phone_number", "state", "contestant_number", "created"]}, "gold_py": null}}
{"db_id": "car_1", "query": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;", "query_toks": ["SELECT", "max", "(", "Accelerate", ")", ",", "Cylinders", "FROM", "CARS_DATA", "GROUP", "BY", "Cylinders", ";"], "query_toks_no_value": ["select", "max", "(", "accelerate", ")", ",", "cylinders", "from", "cars_data", "group", "by", "cylinders"], "question": "What is the maximum accelerate for different number of cylinders?", "question_toks": ["What", "is", "the", "maximum", "accelerate", "for", "different", "number", "of", "cylinders", "?"], "sql": {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[1, [0, [0, 22, false], null]], [0, [0, [0, 18, false], null]]]], "where": [], "groupBy": [[0, 18, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [[13.5, 3], [24.8, 4], [20.1, 5], [21.0, 6], [22.2, 8]], "results": {"generated_sql": "SELECT cylinders ,  max(accelerate) FROM cars_data GROUP BY cylinders", "generated_py": "t1 = cars_data.groupby('cylinders').max()\nanswer = t1['accelerate']", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[(3, 13.5), (4, 24.8), (5, 20.1), (6, 21.0), (8, 22.2)]", "py_exec_result": "cylinders\n3    13.5\n4    24.8\n5    20.1\n6    21.0\n8    22.2\nName: accelerate, dtype: float64", "gold_answer": [[13.5, 3], [24.8, 4], [20.1, 5], [21.0, 6], [22.2, 8]], "gold_sql": "SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "poker_player", "query": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "query_toks": ["SELECT", "T2.Money_Rank", "FROM", "people", "AS", "T1", "JOIN", "poker_player", "AS", "T2", "ON", "T1.People_ID", "=", "T2.People_ID", "ORDER", "BY", "T1.Height", "DESC", "LIMIT", "1"], "query_toks_no_value": ["select", "t2", ".", "money_rank", "from", "people", "as", "t1", "join", "poker_player", "as", "t2", "on", "t1", ".", "people_id", "=", "t2", ".", "people_id", "order", "by", "t1", ".", "height", "desc", "limit", "value"], "question": "What is the money rank of the tallest poker player?", "question_toks": ["What", "is", "the", "money", "rank", "of", "the", "tallest", "poker", "player", "?"], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 7, false], null], [0, 2, false], null]]}, "select": [false, [[0, [0, [0, 5, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["desc", [[0, [0, 11, false], null]]], "limit": 1, "intersect": null, "union": null, "except": null}, "db_table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "answer": [[68.0]], "results": {"generated_sql": "SELECT money_rank FROM poker_player AS T1 JOIN people AS T2 ON T1.people_id  =  T2.people_id ORDER BY height DESC LIMIT 1", "generated_py": "t1 = pd.merge(poker_player, people, on='people_id')\nt2 = t1.sort_values('height', ascending=False).head(1)\nanswer = t2['money_rank']", "sql_error": null, "py_error": "ERROR: 'model'", "sql_exec_result": "[(68.0,)]", "py_exec_result": "0    68.0\nName: money_rank, dtype: float64", "gold_answer": [[68.0]], "gold_sql": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "gold_py": null}}
{"db_id": "flight_2", "query": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"", "query_toks": ["SELECT", "T1.Airline", "FROM", "AIRLINES", "AS", "T1", "JOIN", "FLIGHTS", "AS", "T2", "ON", "T1.uid", "=", "T2.Airline", "WHERE", "T2.SourceAirport", "=", "``", "CVO", "''", "EXCEPT", "SELECT", "T1.Airline", "FROM", "AIRLINES", "AS", "T1", "JOIN", "FLIGHTS", "AS", "T2", "ON", "T1.uid", "=", "T2.Airline", "WHERE", "T2.SourceAirport", "=", "``", "APG", "''"], "query_toks_no_value": ["select", "t1", ".", "airline", "from", "airlines", "as", "t1", "join", "flights", "as", "t2", "on", "t1", ".", "uid", "=", "t2", ".", "airline", "where", "t2", ".", "sourceairport", "=", "value", "except", "select", "t1", ".", "airline", "from", "airlines", "as", "t1", "join", "flights", "as", "t2", "on", "t1", ".", "uid", "=", "t2", ".", "airline", "where", "t2", ".", "sourceairport", "=", "value"], "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.", "question_toks": ["Find", "all", "airlines", "that", "have", "flights", "from", "airport", "'CVO", "'", "but", "not", "from", "'APG", "'", "."], "sql": {"from": {"table_units": [["table_unit", 0], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 1, false], null], [0, 10, false], null]]}, "select": [false, [[0, [0, [0, 2, false], null]]]], "where": [[false, 2, [0, [0, 12, false], null], "\"CVO\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": {"from": {"table_units": [["table_unit", 0], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 1, false], null], [0, 10, false], null]]}, "select": [false, [[0, [0, [0, 2, false], null]]]], "where": [[false, 2, [0, [0, 12, false], null], "\"APG\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}}, "db_table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "answer": [], "results": {"generated_sql": "SELECT DISTINCT T1.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.AirportCode  =  'CVO' EXCEPT SELECT DISTINCT T1.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.AirportCode  =  'APG'", "generated_py": "t1 = pd.merge(flights, airports, left_on='sourceairport', right_on='airportcode')\nt2 = pd.merge(t1, airlines, left_on='airline', right_on='uid')\nt3 = t2[t2['airportcode'] == 'CVO']\nt4 = t3.groupby('airline').size().rename('count')\nt5 = t4.to_frame().reset_index()\nt6 = pd.merge(flights, airports, left_on='sourceairport', right_on='airportcode')\nt7 = pd.merge(t6, airlines, left_on='airline', right_on='uid')\nt8 = t7[t7['airportcode'] == 'APG']\nt9 = t8.groupby", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[]", "py_exec_result": "None", "gold_answer": [], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"", "table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "gold_py": null}}
{"db_id": "tvshow", "query": "SELECT Title FROM Cartoon ORDER BY title", "query_toks": ["SELECT", "Title", "FROM", "Cartoon", "ORDER", "BY", "title"], "query_toks_no_value": ["select", "title", "from", "cartoon", "order", "by", "title"], "question": "List the title of all cartoons in alphabetical order.", "question_toks": ["List", "the", "title", "of", "all", "cartoons", "in", "alphabetical", "order", "."], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 20, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": ["asc", [[0, [0, 20, false], null]]], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "answer": [["Dawn of the Dead Man!"], ["Day of the Dark Knight!"], ["Deep Cover for Batman!"], ["Enter the Outsiders!"], ["Evil Under the Sea!"], ["Fall of the Blue Beetle!"], ["Invasion of the Secret Santas!"], ["Journey to the Center of the Bat!"], ["Return of the Fearsome Fangs!"], ["Terror on Dinosaur Island!"], ["The Eyes of Despero!"], ["The Rise of the Blue Beetle!"]], "results": {"generated_sql": "SELECT title FROM cartoon ORDER BY title", "generated_py": "answer = Cartoon['title'].sort_values()", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[('Dawn of the Dead Man!',), ('Day of the Dark Knight!',), ('Deep Cover for Batman!',), ('Enter the Outsiders!',), ('Evil Under the Sea!',), ('Fall of the Blue Beetle!',), ('Invasion of the Secret Santas!',), ('Journey to the Center of the Bat!',), ('Return of the Fearsome Fangs!',), ('Terror on Dinosaur Island!',), ('The Eyes of Despero!',), ('The Rise of the Blue Beetle!',)]", "py_exec_result": "6                 Dawn of the Dead Man!\n3               Day of the Dark Knight!\n11               Deep Cover for Batman!\n5                  Enter the Outsiders!\n2                   Evil Under the Sea!\n7              Fall of the Blue Beetle!\n4        Invasion of the Secret Santas!\n8     Journey to the Center of the Bat!\n10        Return of the Fearsome Fangs!\n1            Terror on Dinosaur Island!\n9                  The Eyes of Despero!\n0          The Rise of the Blue Beetle!\nName: title, dtype: object", "gold_answer": [["Dawn of the Dead Man!"], ["Day of the Dark Knight!"], ["Deep Cover for Batman!"], ["Enter the Outsiders!"], ["Evil Under the Sea!"], ["Fall of the Blue Beetle!"], ["Invasion of the Secret Santas!"], ["Journey to the Center of the Bat!"], ["Return of the Fearsome Fangs!"], ["Terror on Dinosaur Island!"], ["The Eyes of Despero!"], ["The Rise of the Blue Beetle!"]], "gold_sql": "SELECT Title FROM Cartoon ORDER BY title", "table_headers": {"TV_Channel": ["id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", "Package_Option"], "TV_series": ["id", "Episode", "Air_Date", "Rating", "Share", "18_49_Rating_Share", "Viewers_m", "Weekly_Rank", "Channel"], "Cartoon": ["id", "Title", "Directed_by", "Written_by", "Original_air_date", "Production_code", "Channel"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "query_toks": ["SELECT", "template_id", "FROM", "Documents", "GROUP", "BY", "template_id", "HAVING", "count", "(", "*", ")", ">", "1"], "query_toks_no_value": ["select", "template_id", "from", "documents", "group", "by", "template_id", "having", "count", "(", "*", ")", ">", "value"], "question": "Show ids for all templates that are used by more than one document.", "question_toks": ["Show", "ids", "for", "all", "templates", "that", "are", "used", "by", "more", "than", "one", "document", "."], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 10, false], null]]]], "where": [], "groupBy": [[0, 10, false]], "having": [[false, 3, [0, [3, 0, false], null], 1.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [[11], [14], [25]], "results": {"generated_sql": "SELECT T1.Template_ID FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID  =  T2.Template_ID GROUP BY T1.Template_ID HAVING count(*)  >  1", "generated_py": "t1 = pd.merge(Documents, Templates, left_on='template_id', right_on='template_id')\nt2 = t1.groupby(['template_id']).size().rename('count')\nanswer = t2[t2 > 1].to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[(11,), (14,), (25,)]", "py_exec_result": "   template_id  count\n0           11      2\n1           14      2\n2           25      2", "gold_answer": [[11], [14], [25]], "gold_sql": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "dog_kennels", "query": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "query_toks": ["SELECT", "T1.last_name", "FROM", "Owners", "AS", "T1", "JOIN", "Dogs", "AS", "T2", "ON", "T1.owner_id", "=", "T2.owner_id", "WHERE", "T2.age", "=", "(", "SELECT", "max", "(", "age", ")", "FROM", "Dogs", ")"], "query_toks_no_value": ["select", "t1", ".", "last_name", "from", "owners", "as", "t1", "join", "dogs", "as", "t2", "on", "t1", ".", "owner_id", "=", "t2", ".", "owner_id", "where", "t2", ".", "age", "=", "(", "select", "max", "(", "age", ")", "from", "dogs", ")"], "question": "Who owns the youngest dog? Give me his or her last name.", "question_toks": ["Who", "owns", "the", "youngest", "dog", "?", "Give", "me", "his", "or", "her", "last", "name", "."], "sql": {"from": {"table_units": [["table_unit", 4], ["table_unit", 5]], "conds": [[false, 2, [0, [0, 10, false], null], [0, 21, false], null]]}, "select": [false, [[0, [0, [0, 12, false], null]]]], "where": [[false, 2, [0, [0, 26, false], null], {"from": {"table_units": [["table_unit", 5]], "conds": []}, "select": [false, [[1, [0, [0, 26, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Breeds": ["breed_code", "breed_name"], "Charges": ["charge_id", "charge_type", "charge_amount"], "Sizes": ["size_code", "size_description"], "Treatment_Types": ["treatment_type_code", "treatment_type_description"], "Owners": ["owner_id", "first_name", "last_name", "street", "city", "state", "zip_code", "email_address", "home_phone", "cell_number"], "Dogs": ["dog_id", "owner_id", "abandoned_yn", "breed_code", "size_code", "name", "age", "date_of_birth", "gender", "weight", "date_arrived", "date_adopted", "date_departed"], "Professionals": ["professional_id", "role_code", "first_name", "street", "city", "state", "zip_code", "last_name", "email_address", "home_phone", "cell_number"], "Treatments": ["treatment_id", "dog_id", "professional_id", "treatment_type_code", "date_of_treatment", "cost_of_treatment"]}, "answer": [["Feil"], ["Fisher"], ["Rippin"]], "results": {"generated_sql": "SELECT T2.last_name FROM dogs AS T1 JOIN owners AS T2 ON T1.owner_id  =  T2.owner_id ORDER BY T1.age ASC LIMIT 1", "generated_py": "t1 = pd.merge(Owners, Dogs, left_on='owner_id', right_on='owner_id')\nt2 = t1.sort_values('age').head(1)\nanswer = t2['last_name']", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[('Nicolas',)]", "py_exec_result": "8    Nicolas\nName: last_name, dtype: object", "gold_answer": [["Feil"], ["Fisher"], ["Rippin"]], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "table_headers": {"Breeds": ["breed_code", "breed_name"], "Charges": ["charge_id", "charge_type", "charge_amount"], "Sizes": ["size_code", "size_description"], "Treatment_Types": ["treatment_type_code", "treatment_type_description"], "Owners": ["owner_id", "first_name", "last_name", "street", "city", "state", "zip_code", "email_address", "home_phone", "cell_number"], "Dogs": ["dog_id", "owner_id", "abandoned_yn", "breed_code", "size_code", "name", "age", "date_of_birth", "gender", "weight", "date_arrived", "date_adopted", "date_departed"], "Professionals": ["professional_id", "role_code", "first_name", "street", "city", "state", "zip_code", "last_name", "email_address", "home_phone", "cell_number"], "Treatments": ["treatment_id", "dog_id", "professional_id", "treatment_type_code", "date_of_treatment", "cost_of_treatment"]}, "gold_py": null}}
{"db_id": "network_1", "query": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id", "query_toks": ["SELECT", "T2.name", ",", "count", "(", "*", ")", "FROM", "Likes", "AS", "T1", "JOIN", "Highschooler", "AS", "T2", "ON", "T1.student_id", "=", "T2.id", "GROUP", "BY", "T1.student_id"], "query_toks_no_value": ["select", "t2", ".", "name", ",", "count", "(", "*", ")", "from", "likes", "as", "t1", "join", "highschooler", "as", "t2", "on", "t1", ".", "student_id", "=", "t2", ".", "id", "group", "by", "t1", ".", "student_id"], "question": "What are the names of high schoolers who have likes, and how many likes does each have?", "question_toks": ["What", "are", "the", "names", "of", "high", "schoolers", "who", "have", "likes", ",", "and", "how", "many", "likes", "does", "each", "have", "?"], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 0]], "conds": [[false, 2, [0, [0, 6, false], null], [0, 1, false], null]]}, "select": [false, [[0, [0, [0, 2, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 6, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Highschooler": ["ID", "name", "grade"], "Friend": ["student_id", "friend_id"], "Likes": ["student_id", "liked_id"]}, "answer": [["John", 1], ["Alexis", 1], ["Austin", 1], ["Jessica", 1], ["Brittany", 1], ["Gabriel", 1], ["Cassandra", 1], ["Andrew", 1], ["Gabriel", 1], ["Kyle", 1]], "results": {"generated_sql": "SELECT T1.name ,  count(*) FROM Highschooler AS T1 JOIN Likes AS T2 ON T1.ID  =  T2.student_id GROUP BY T1.name", "generated_py": "t1 = pd.merge(Highschooler, Likes, left_on='id', right_on='student_id')\nt2 = t1.groupby('name').size().rename('count')\nanswer = t2.to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[('Alexis', 1), ('Andrew', 1), ('Austin', 1), ('Brittany', 1), ('Cassandra', 1), ('Gabriel', 2), ('Jessica', 1), ('John', 1), ('Kyle', 1)]", "py_exec_result": "        name  count\n0     Alexis      1\n1     Andrew      1\n2     Austin      1\n3   Brittany      1\n4  Cassandra      1\n5    Gabriel      2\n6    Jessica      1\n7       John      1\n8       Kyle      1", "gold_answer": [["John", 1], ["Alexis", 1], ["Austin", 1], ["Jessica", 1], ["Brittany", 1], ["Gabriel", 1], ["Cassandra", 1], ["Andrew", 1], ["Gabriel", 1], ["Kyle", 1]], "gold_sql": "SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id", "table_headers": {"Highschooler": ["ID", "name", "grade"], "Friend": ["student_id", "friend_id"], "Likes": ["student_id", "liked_id"]}, "gold_py": null}}
{"db_id": "world_1", "query": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  \"Asia\")", "query_toks": ["SELECT", "Name", "FROM", "country", "WHERE", "Continent", "=", "``", "Africa", "''", "AND", "population", "<", "(", "SELECT", "max", "(", "population", ")", "FROM", "country", "WHERE", "Continent", "=", "``", "Asia", "''", ")"], "query_toks_no_value": ["select", "name", "from", "country", "where", "continent", "=", "value", "and", "population", "<", "(", "select", "max", "(", "population", ")", "from", "country", "where", "continent", "=", "value", ")"], "question": "What are the African countries that have a  population less than any country in Asia?", "question_toks": ["What", "are", "the", "African", "countries", "that", "have", "a", "population", "less", "than", "any", "country", "in", "Asia", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 9, false], null]]]], "where": [[false, 2, [0, [0, 10, false], null], "\"Africa\"", null], "and", [false, 4, [0, [0, 14, false], null], {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[1, [0, [0, 14, false], null]]]], "where": [[false, 2, [0, [0, 10, false], null], "\"Asia\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "answer": [["Angola"], ["Burundi"], ["Benin"], ["Burkina Faso"], ["Botswana"], ["Central African Republic"], ["C\u00f4te d\u2019Ivoire"], ["Cameroon"], ["Congo, The Democratic Republic of the"], ["Congo"], ["Comoros"], ["Cape Verde"], ["Djibouti"], ["Algeria"], ["Egypt"], ["Eritrea"], ["Western Sahara"], ["Ethiopia"], ["Gabon"], ["Ghana"], ["Guinea"], ["Gambia"], ["Guinea-Bissau"], ["Equatorial Guinea"], ["British Indian Ocean Territory"], ["Kenya"], ["Liberia"], ["Libyan Arab Jamahiriya"], ["Lesotho"], ["Morocco"], ["Madagascar"], ["Mali"], ["Mozambique"], ["Mauritania"], ["Mauritius"], ["Malawi"], ["Mayotte"], ["Namibia"], ["Niger"], ["Nigeria"], ["R\u00e9union"], ["Rwanda"], ["Sudan"], ["Senegal"], ["Saint Helena"], ["Sierra Leone"], ["Somalia"], ["Sao Tome and Principe"], ["Swaziland"], ["Seychelles"], ["Chad"], ["Togo"], ["Tunisia"], ["Tanzania"], ["Uganda"], ["South Africa"], ["Zambia"], ["Zimbabwe"]], "results": {"generated_sql": "SELECT T1.name FROM country AS T1 WHERE T1.continent  =  'Africa' AND T1.population  <  (SELECT min(T2.population) FROM country AS T2 WHERE T2.continent  =  'Asia')", "generated_py": "t1 = country[country['continent'] == 'Asia']\nt2 = country[country['continent'] == 'Africa']\nt3 = t2[t2['population'] < t1['population'].min()]\nanswer = t3['name']", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[('British Indian Ocean Territory',), ('Mayotte',), ('Saint Helena',), ('Sao Tome and Principe',), ('Seychelles',)]", "py_exec_result": "100    British Indian Ocean Territory\n150                           Mayotte\n188                      Saint Helena\n196             Sao Tome and Principe\n202                        Seychelles\nName: name, dtype: object", "gold_answer": [["Angola"], ["Burundi"], ["Benin"], ["Burkina Faso"], ["Botswana"], ["Central African Republic"], ["C\u00f4te d\u2019Ivoire"], ["Cameroon"], ["Congo, The Democratic Republic of the"], ["Congo"], ["Comoros"], ["Cape Verde"], ["Djibouti"], ["Algeria"], ["Egypt"], ["Eritrea"], ["Western Sahara"], ["Ethiopia"], ["Gabon"], ["Ghana"], ["Guinea"], ["Gambia"], ["Guinea-Bissau"], ["Equatorial Guinea"], ["British Indian Ocean Territory"], ["Kenya"], ["Liberia"], ["Libyan Arab Jamahiriya"], ["Lesotho"], ["Morocco"], ["Madagascar"], ["Mali"], ["Mozambique"], ["Mauritania"], ["Mauritius"], ["Malawi"], ["Mayotte"], ["Namibia"], ["Niger"], ["Nigeria"], ["R\u00e9union"], ["Rwanda"], ["Sudan"], ["Senegal"], ["Saint Helena"], ["Sierra Leone"], ["Somalia"], ["Sao Tome and Principe"], ["Swaziland"], ["Seychelles"], ["Chad"], ["Togo"], ["Tunisia"], ["Tanzania"], ["Uganda"], ["South Africa"], ["Zambia"], ["Zimbabwe"]], "gold_sql": "SELECT Name FROM country WHERE Continent  =  \"Africa\"  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  \"Asia\")", "table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT template_id ,  version_number ,  template_type_code FROM Templates", "query_toks": ["SELECT", "template_id", ",", "version_number", ",", "template_type_code", "FROM", "Templates"], "query_toks_no_value": ["select", "template_id", ",", "version_number", ",", "template_type_code", "from", "templates"], "question": "What are the ids, version numbers, and type codes for each template?", "question_toks": ["What", "are", "the", "ids", ",", "version", "numbers", ",", "and", "type", "codes", "for", "each", "template", "?"], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 3, false], null]], [0, [0, [0, 4, false], null]], [0, [0, [0, 5, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [[0, 5, "PP"], [1, 9, "PP"], [4, 4, "BK"], [6, 2, "PPT"], [7, 8, "PPT"], [8, 3, "BK"], [9, 2, "BK"], [10, 1, "PPT"], [11, 6, "BK"], [14, 7, "AD"], [15, 9, "CV"], [16, 5, "CV"], [18, 5, "PP"], [19, 7, "AD"], [20, 6, "BK"], [21, 9, "AD"], [22, 0, "PP"], [23, 2, "BK"], [24, 8, "PP"], [25, 5, "PP"]], "results": {"generated_sql": "SELECT Template_ID ,  Version_Number ,  Template_Type_Code FROM Templates", "generated_py": "t1 = pd.merge(Templates, Ref_Template_Types, left_on='template_type_code', right_on='template_type_code')\nanswer = t1[['template_id', 'version_number', 'template_type_code']]", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[(0, 5, 'PP'), (1, 9, 'PP'), (4, 4, 'BK'), (6, 2, 'PPT'), (7, 8, 'PPT'), (8, 3, 'BK'), (9, 2, 'BK'), (10, 1, 'PPT'), (11, 6, 'BK'), (14, 7, 'AD'), (15, 9, 'CV'), (16, 5, 'CV'), (18, 5, 'PP'), (19, 7, 'AD'), (20, 6, 'BK'), (21, 9, 'AD'), (22, 0, 'PP'), (23, 2, 'BK'), (24, 8, 'PP'), (25, 5, 'PP')]", "py_exec_result": "    template_id  version_number template_type_code\n0             0               5                 PP\n1             1               9                 PP\n2            18               5                 PP\n3            22               0                 PP\n4            24               8                 PP\n5            25               5                 PP\n6             4               4                 BK\n7             8               3                 BK\n8             9               2                 BK\n9            11               6                 BK\n10           20               6                 BK\n11           23               2                 BK\n12            6               2                PPT\n13            7               8                PPT\n14           10               1                PPT\n15           14               7                 AD\n16           19               7                 AD\n17           21               9                 AD\n18           15               9                 CV\n19           16               5                 CV", "gold_answer": [[0, 5, "PP"], [1, 9, "PP"], [4, 4, "BK"], [6, 2, "PPT"], [7, 8, "PPT"], [8, 3, "BK"], [9, 2, "BK"], [10, 1, "PPT"], [11, 6, "BK"], [14, 7, "AD"], [15, 9, "CV"], [16, 5, "CV"], [18, 5, "PP"], [19, 7, "AD"], [20, 6, "BK"], [21, 9, "AD"], [22, 0, "PP"], [23, 2, "BK"], [24, 8, "PP"], [25, 5, "PP"]], "gold_sql": "SELECT template_id ,  version_number ,  template_type_code FROM Templates", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "course_teach", "query": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2", "query_toks": ["SELECT", "Hometown", "FROM", "teacher", "GROUP", "BY", "Hometown", "HAVING", "COUNT", "(", "*", ")", ">", "=", "2"], "query_toks_no_value": ["select", "hometown", "from", "teacher", "group", "by", "hometown", "having", "count", "(", "*", ")", ">", "=", "value"], "question": "Show the hometowns shared by at least two teachers.", "question_toks": ["Show", "the", "hometowns", "shared", "by", "at", "least", "two", "teachers", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 7, false], null]]]], "where": [], "groupBy": [[0, 7, false]], "having": [[false, 5, [0, [3, 0, false], null], 2.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"course": ["Course_ID", "Staring_Date", "Course"], "teacher": ["Teacher_ID", "Name", "Age", "Hometown"], "course_arrange": ["Course_ID", "Teacher_ID", "Grade"]}, "answer": [], "results": {"generated_sql": "SELECT hometown FROM teacher GROUP BY hometown HAVING count(*)  >  1", "generated_py": "t1 = pd.merge(teacher, course_arrange, on='teacher_id')\nt2 = t1.groupby('hometown').size().rename('count')\nanswer = t2[t2 > 1].to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: 'airline'", "sql_exec_result": "[]", "py_exec_result": "                      hometown  count\n0  Little Lever Urban District      2", "gold_answer": [], "gold_sql": "SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2", "table_headers": {"course": ["Course_ID", "Staring_Date", "Course"], "teacher": ["Teacher_ID", "Name", "Age", "Hometown"], "course_arrange": ["Course_ID", "Teacher_ID", "Grade"]}, "gold_py": null}}
{"db_id": "car_1", "query": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "query_toks": ["select", "count", "(", "*", ")", "from", "countries", "as", "t1", "join", "car_makers", "as", "t2", "on", "t1.countryid", "=", "t2.country", "group", "by", "t1.countryid", "having", "count", "(", "*", ")", ">", "2"], "query_toks_no_value": ["select", "count", "(", "*", ")", "from", "countries", "as", "t1", "join", "car_makers", "as", "t2", "on", "t1", ".", "countryid", "=", "t2", ".", "country", "group", "by", "t1", ".", "countryid", "having", "count", "(", "*", ")", ">", "value"], "question": "How many countries has more than 2 car makers ?", "question_toks": ["How", "many", "countries", "has", "more", "than", "2", "car", "makers", "?"], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 3, false], null], [0, 9, false], null]]}, "select": [false, [[3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 3, false]], "having": [[false, 3, [0, [3, 0, false], null], 2.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "answer": [[4], [4], [3], [5]], "results": {"generated_sql": "SELECT count(*) FROM (SELECT T1.CountryId ,  count(*) FROM countries AS T1 JOIN car_makers AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >  2)", "generated_py": "t1 = pd.merge(countries, car_makers, left_on='countryid', right_on='country')\nt2 = t1.groupby('countryname').size().rename('count')\nanswer = t2[t2 > 2].size", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(4,)]", "py_exec_result": "None", "gold_answer": [[4], [4], [3], [5]], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "table_headers": {"continents": ["ContId", "Continent"], "countries": ["CountryId", "CountryName", "Continent"], "car_makers": ["Id", "Maker", "FullName", "Country"], "model_list": ["ModelId", "Maker", "Model"], "car_names": ["MakeId", "Model", "Make"], "cars_data": ["Id", "MPG", "Cylinders", "Edispl", "Horsepower", "Weight", "Accelerate", "Year"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code", "query_toks": ["SELECT", "template_type_code", ",", "count", "(", "*", ")", "FROM", "Templates", "GROUP", "BY", "template_type_code"], "query_toks_no_value": ["select", "template_type_code", ",", "count", "(", "*", ")", "from", "templates", "group", "by", "template_type_code"], "question": "Show all template type codes and number of templates for each.", "question_toks": ["Show", "all", "template", "type", "codes", "and", "number", "of", "templates", "for", "each", "."], "sql": {"from": {"table_units": [["table_unit", 1]], "conds": []}, "select": [false, [[0, [0, [0, 5, false], null]], [3, [0, [0, 0, false], null]]]], "where": [], "groupBy": [[0, 5, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [["AD", 3], ["BK", 6], ["CV", 2], ["PP", 6], ["PPT", 3]], "results": {"generated_sql": "SELECT T1.Template_Type_Code ,  count(*) FROM Templates AS T1 GROUP BY T1.Template_Type_Code", "generated_py": "t1 = pd.merge(Templates, Ref_Template_Types, left_on='template_type_code', right_on='template_type_code')\nt2 = t1.groupby(['template_type_code']).size().rename('count')\nanswer = t2.to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('AD', 3), ('BK', 6), ('CV', 2), ('PP', 6), ('PPT', 3)]", "py_exec_result": "  template_type_code  count\n0                 AD      3\n1                 BK      6\n2                 CV      2\n3                 PP      6\n4                PPT      3", "gold_answer": [["AD", 3], ["BK", 6], ["CV", 2], ["PP", 6], ["PPT", 3]], "gold_sql": "SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "flight_2", "query": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"", "query_toks": ["SELECT", "Airline", "FROM", "AIRLINES", "WHERE", "Abbreviation", "=", "``", "UAL", "''"], "query_toks_no_value": ["select", "airline", "from", "airlines", "where", "abbreviation", "=", "value"], "question": "Give the airline with abbreviation 'UAL'.", "question_toks": ["Give", "the", "airline", "with", "abbreviation", "'UAL", "'", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 2, false], null]]]], "where": [[false, 2, [0, [0, 3, false], null], "\"UAL\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "answer": [["United Airlines"]], "results": {"generated_sql": "SELECT Airline FROM airlines WHERE Abbreviation  =  'UAL'", "generated_py": "answer = airlines[airlines['abbreviation'] == 'UAL']['airline']", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('United Airlines',)]", "py_exec_result": "0    United Airlines\nName: airline, dtype: object", "gold_answer": [["United Airlines"]], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  \"UAL\"", "table_headers": {"airlines": ["uid", "Airline", "Abbreviation", "Country"], "airports": ["City", "AirportCode", "AirportName", "Country", "CountryAbbrev"], "flights": ["Airline", "FlightNo", "SourceAirport", "DestAirport"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "query_toks": ["SELECT", "template_id", "FROM", "Documents", "GROUP", "BY", "template_id", "HAVING", "count", "(", "*", ")", ">", "1"], "query_toks_no_value": ["select", "template_id", "from", "documents", "group", "by", "template_id", "having", "count", "(", "*", ")", ">", "value"], "question": "What are the template ids of any templates used in more than a single document?", "question_toks": ["What", "are", "the", "template", "ids", "of", "any", "templates", "used", "in", "more", "than", "a", "single", "document", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 10, false], null]]]], "where": [], "groupBy": [[0, 10, false]], "having": [[false, 3, [0, [3, 0, false], null], 1.0, null]], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [[11], [14], [25]], "results": {"generated_sql": "SELECT T1.Template_ID FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID  =  T2.Template_ID GROUP BY T1.Template_ID HAVING count(*)  >  1", "generated_py": "t1 = pd.merge(Documents, Templates, on='template_id')\nt2 = t1.groupby('template_id').size().rename('count')\nanswer = t2[t2 > 1].to_frame().reset_index()", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(11,), (14,), (25,)]", "py_exec_result": "   template_id  count\n0           11      2\n1           14      2\n2           25      2", "gold_answer": [[11], [14], [25]], "gold_sql": "SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT template_type_code ,  template_type_description FROM Ref_template_types", "query_toks": ["SELECT", "template_type_code", ",", "template_type_description", "FROM", "Ref_template_types"], "query_toks_no_value": ["select", "template_type_code", ",", "template_type_description", "from", "ref_template_types"], "question": "Show all template type codes and descriptions.", "question_toks": ["Show", "all", "template", "type", "codes", "and", "descriptions", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 1, false], null]], [0, [0, [0, 2, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [["PPT", "Presentation"], ["CV", "CV"], ["AD", "Advertisement"], ["PP", "Paper"], ["BK", "Book"]], "results": {"generated_sql": "SELECT Template_Type_Code ,  Template_Type_Description FROM Ref_Template_Types", "generated_py": "answer = Ref_Template_Types[['template_type_code', 'template_type_description']]", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('PPT', 'Presentation'), ('CV', 'CV'), ('AD', 'Advertisement'), ('PP', 'Paper'), ('BK', 'Book')]", "py_exec_result": "  template_type_code template_type_description\n0                PPT              Presentation\n1                 CV                        CV\n2                 AD             Advertisement\n3                 PP                     Paper\n4                 BK                      Book", "gold_answer": [["PPT", "Presentation"], ["CV", "CV"], ["AD", "Advertisement"], ["PP", "Paper"], ["BK", "Book"]], "gold_sql": "SELECT template_type_code ,  template_type_description FROM Ref_template_types", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
{"db_id": "world_1", "query": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"", "query_toks": ["SELECT", "sum", "(", "SurfaceArea", ")", "FROM", "country", "WHERE", "Continent", "=", "``", "Asia", "''", "OR", "Continent", "=", "``", "Europe", "''"], "query_toks_no_value": ["select", "sum", "(", "surfacearea", ")", "from", "country", "where", "continent", "=", "value", "or", "continent", "=", "value"], "question": "What is the total surface area of the continents Asia and Europe?", "question_toks": ["What", "is", "the", "total", "surface", "area", "of", "the", "continents", "Asia", "and", "Europe", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[4, [0, [0, 12, false], null]]]], "where": [[false, 2, [0, [0, 10, false], null], "\"Asia\"", null], "or", [false, 2, [0, [0, 10, false], null], "\"Europe\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "answer": [[54930138.9]], "results": {"generated_sql": "SELECT sum(surfacearea) FROM country WHERE continent  =  'Asia' OR continent  =  'Europe'", "generated_py": "t1 = country[(country['continent'] == 'Asia') | (country['continent'] == 'Europe')]\nanswer = pd.Series(t1['surfacearea'].sum())", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(54930138.9,)]", "py_exec_result": "0    54930138.9\ndtype: float64", "gold_answer": [[54930138.9]], "gold_sql": "SELECT sum(SurfaceArea) FROM country WHERE Continent  =  \"Asia\" OR Continent  =  \"Europe\"", "table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "gold_py": null}}
{"db_id": "course_teach", "query": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID", "query_toks": ["SELECT", "T3.Name", ",", "T2.Course", "FROM", "course_arrange", "AS", "T1", "JOIN", "course", "AS", "T2", "ON", "T1.Course_ID", "=", "T2.Course_ID", "JOIN", "teacher", "AS", "T3", "ON", "T1.Teacher_ID", "=", "T3.Teacher_ID"], "query_toks_no_value": ["select", "t3", ".", "name", ",", "t2", ".", "course", "from", "course_arrange", "as", "t1", "join", "course", "as", "t2", "on", "t1", ".", "course_id", "=", "t2", ".", "course_id", "join", "teacher", "as", "t3", "on", "t1", ".", "teacher_id", "=", "t3", ".", "teacher_id"], "question": "Show names of teachers and the courses they are arranged to teach.", "question_toks": ["Show", "names", "of", "teachers", "and", "the", "courses", "they", "are", "arranged", "to", "teach", "."], "sql": {"from": {"table_units": [["table_unit", 2], ["table_unit", 0], ["table_unit", 1]], "conds": [[false, 2, [0, [0, 8, false], null], [0, 1, false], null], "and", [false, 2, [0, [0, 9, false], null], [0, 4, false], null]]}, "select": [false, [[0, [0, [0, 5, false], null]], [0, [0, [0, 3, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"course": ["Course_ID", "Staring_Date", "Course"], "teacher": ["Teacher_ID", "Name", "Age", "Hometown"], "course_arrange": ["Course_ID", "Teacher_ID", "Grade"]}, "answer": [["Kearsley Brown", "Math"], ["Vicente Carretero", "Math"], ["Gustaaf Deloor", "Science"], ["Anne Walker", "History"], ["Anne Walker", "Bible"], ["Lucy Wong", "Music"]], "results": {"generated_sql": "SELECT T1.name ,  T2.course FROM teacher AS T1 JOIN course_arrange AS T3 ON T1.teacher_id  =  T3.teacher_id JOIN course AS T2 ON T3.course_id  =  T2.course_id", "generated_py": "t1 = pd.merge(course_arrange, teacher, left_on='teacher_id', right_on='teacher_id')\nt2 = pd.merge(t1, course, left_on='course_id', right_on='course_id')\nanswer = t2[['name', 'course']]", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('Kearsley Brown', 'Math'), ('Vicente Carretero', 'Math'), ('Gustaaf Deloor', 'Science'), ('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Lucy Wong', 'Music')]", "py_exec_result": "                name   course\n0     Kearsley Brown     Math\n1  Vicente Carretero     Math\n2     Gustaaf Deloor  Science\n3        Anne Walker  History\n4        Anne Walker    Bible\n5          Lucy Wong    Music", "gold_answer": [["Kearsley Brown", "Math"], ["Vicente Carretero", "Math"], ["Gustaaf Deloor", "Science"], ["Anne Walker", "History"], ["Anne Walker", "Bible"], ["Lucy Wong", "Music"]], "gold_sql": "SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID", "table_headers": {"course": ["Course_ID", "Staring_Date", "Course"], "teacher": ["Teacher_ID", "Name", "Age", "Hometown"], "course_arrange": ["Course_ID", "Teacher_ID", "Grade"]}, "gold_py": null}}
{"db_id": "world_1", "query": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "query_toks": ["SELECT", "count", "(", "*", ")", ",", "max", "(", "Percentage", ")", "FROM", "countrylanguage", "WHERE", "LANGUAGE", "=", "``", "Spanish", "''", "GROUP", "BY", "CountryCode"], "query_toks_no_value": ["select", "count", "(", "*", ")", ",", "max", "(", "percentage", ")", "from", "countrylanguage", "where", "language", "=", "value", "group", "by", "countrycode"], "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "question_toks": ["What", "is", "the", "total", "number", "of", "countries", "where", "Spanish", "is", "spoken", "by", "the", "largest", "percentage", "of", "people", "?"], "sql": {"from": {"table_units": [["table_unit", 3]], "conds": []}, "select": [false, [[3, [0, [0, 0, false], null]], [1, [0, [0, 26, false], null]]]], "where": [[false, 2, [0, [0, 24, false], null], "\"Spanish\"", null]], "groupBy": [[0, 23, false]], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "answer": [[1, 7.4], [1, 44.6], [1, 96.8], [1, 31.6], [1, 87.7], [1, 0.7], [1, 89.7], [1, 99.0], [1, 97.5], [1, 100.0], [1, 98.0], [1, 93.0], [1, 74.4], [1, 0.4], [1, 64.7], [1, 97.2], [1, 92.1], [1, 97.6], [1, 76.8], [1, 79.8], [1, 51.3], [1, 55.1], [1, 100.0], [1, 0.6], [1, 95.7], [1, 7.5], [1, 96.9], [1, 13.3]], "results": {"generated_sql": "SELECT count(*) FROM countrylanguage WHERE percentage  =  (SELECT max(percentage) FROM countrylanguage WHERE language  =  'Spanish')", "generated_py": "t1 = countrylanguage[countrylanguage['language'] == 'Spanish']\nt2 = t1.groupby('countrycode').agg({'percentage': 'max'}).rename(columns={'percentage': 'max_percentage'})\nt3 = pd.merge(t2, country, left_on='countrycode', right_on='code')\nanswer = pd.Series(t3.shape[0])", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(13,)]", "py_exec_result": "0    28\ndtype: int64", "gold_answer": [[1, 7.4], [1, 44.6], [1, 96.8], [1, 31.6], [1, 87.7], [1, 0.7], [1, 89.7], [1, 99.0], [1, 97.5], [1, 100.0], [1, 98.0], [1, 93.0], [1, 74.4], [1, 0.4], [1, 64.7], [1, 97.2], [1, 92.1], [1, 97.6], [1, 76.8], [1, 79.8], [1, 51.3], [1, 55.1], [1, 100.0], [1, 0.6], [1, 95.7], [1, 7.5], [1, 96.9], [1, 13.3]], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "gold_py": null}}
{"db_id": "singer", "query": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955", "query_toks": ["SELECT", "Citizenship", "FROM", "singer", "WHERE", "Birth_Year", "<", "1945", "INTERSECT", "SELECT", "Citizenship", "FROM", "singer", "WHERE", "Birth_Year", ">", "1955"], "query_toks_no_value": ["select", "citizenship", "from", "singer", "where", "birth_year", "<", "value", "intersect", "select", "citizenship", "from", "singer", "where", "birth_year", ">", "value"], "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?", "question_toks": ["What", "are", "the", "citizenships", "that", "are", "shared", "by", "singers", "with", "a", "birth", "year", "before", "1945", "and", "after", "1955", "?"], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 5, false], null]]]], "where": [[false, 4, [0, [0, 3, false], null], 1945.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 5, false], null]]]], "where": [[false, 3, [0, [0, 3, false], null], 1955.0, null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "union": null, "except": null}, "db_table_headers": {"singer": ["Singer_ID", "Name", "Birth_Year", "Net_Worth_Millions", "Citizenship"], "song": ["Song_ID", "Title", "Singer_ID", "Sales", "Highest_Position"]}, "answer": [["United States"]], "results": {"generated_sql": "SELECT DISTINCT T1.citizenship FROM singer AS T1 JOIN song AS T2 ON T1.singer_id  =  T2.singer_id WHERE T1.birth_year  <  1945 AND T1.birth_year  >  1955", "generated_py": "t1 = singer[(singer['birth_year'] < 1945) | (singer['birth_year'] > 1955)]\nanswer = t1['citizenship'].unique()", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[]", "py_exec_result": "['France' 'Chile' 'United States' 'Germany']", "gold_answer": [["United States"]], "gold_sql": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955", "table_headers": {"singer": ["Singer_ID", "Name", "Birth_Year", "Net_Worth_Millions", "Citizenship"], "song": ["Song_ID", "Title", "Singer_ID", "Sales", "Highest_Position"]}, "gold_py": null}}
{"db_id": "poker_player", "query": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player", "query_toks": ["SELECT", "Final_Table_Made", ",", "Best_Finish", "FROM", "poker_player"], "query_toks_no_value": ["select", "final_table_made", ",", "best_finish", "from", "poker_player"], "question": "List the final tables made and the best finishes of poker players.", "question_toks": ["List", "the", "final", "tables", "made", "and", "the", "best", "finishes", "of", "poker", "players", "."], "sql": {"from": {"table_units": [["table_unit", 0]], "conds": []}, "select": [false, [[0, [0, [0, 3, false], null]], [0, [0, [0, 4, false], null]]]], "where": [], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "answer": [[42.0, 1.0], [10.0, 2.0], [21.0, 1.0], [19.0, 2.0], [26.0, 3.0]], "results": {"generated_sql": "SELECT final_table_made ,  best_finish FROM poker_player", "generated_py": "answer = poker_player[['final_table_made', 'best_finish']]", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[(42.0, 1.0), (10.0, 2.0), (21.0, 1.0), (19.0, 2.0), (26.0, 3.0)]", "py_exec_result": "   final_table_made  best_finish\n0              42.0          1.0\n1              10.0          2.0\n2              21.0          1.0\n3              19.0          2.0\n4              26.0          3.0", "gold_answer": [[42.0, 1.0], [10.0, 2.0], [21.0, 1.0], [19.0, 2.0], [26.0, 3.0]], "gold_sql": "SELECT Final_Table_Made ,  Best_Finish FROM poker_player", "table_headers": {"poker_player": ["Poker_Player_ID", "People_ID", "Final_Table_Made", "Best_Finish", "Money_Rank", "Earnings"], "people": ["People_ID", "Nationality", "Name", "Birth_Date", "Height"]}, "gold_py": null}}
{"db_id": "student_transcripts_tracking", "query": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "query_toks": ["SELECT", "section_description", "FROM", "Sections", "WHERE", "section_name", "=", "'h", "'"], "query_toks_no_value": ["select", "section_description", "from", "sections", "where", "section_name", "=", "value"], "question": "Describe the section h.", "question_toks": ["Describe", "the", "section", "h", "."], "sql": {"from": {"table_units": [["table_unit", 4]], "conds": []}, "select": [false, [[0, [0, [0, 26, false], null]]]], "where": [[false, 2, [0, [0, 25, false], null], "\"h\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "answer": [["et"]], "results": {"generated_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "generated_py": "answer = Sections[Sections['section_name'] == 'h']['section_description']", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('et',)]", "py_exec_result": "7    et\nName: section_description, dtype: object", "gold_answer": [["et"]], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "table_headers": {"Addresses": ["address_id", "line_1", "line_2", "line_3", "city", "zip_postcode", "state_province_county", "country", "other_address_details"], "Courses": ["course_id", "course_name", "course_description", "other_details"], "Departments": ["department_id", "department_name", "department_description", "other_details"], "Degree_Programs": ["degree_program_id", "department_id", "degree_summary_name", "degree_summary_description", "other_details"], "Sections": ["section_id", "course_id", "section_name", "section_description", "other_details"], "Semesters": ["semester_id", "semester_name", "semester_description", "other_details"], "Students": ["student_id", "current_address_id", "permanent_address_id", "first_name", "middle_name", "last_name", "cell_mobile_number", "email_address", "ssn", "date_first_registered", "date_left", "other_student_details"], "Student_Enrolment": ["student_enrolment_id", "degree_program_id", "semester_id", "student_id", "other_details"], "Student_Enrolment_Courses": ["student_course_id", "course_id", "student_enrolment_id"], "Transcripts": ["transcript_id", "transcript_date", "other_details"], "Transcript_Contents": ["student_course_id", "transcript_id"]}, "gold_py": null}}
{"db_id": "world_1", "query": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"", "query_toks": ["SELECT", "Population", ",", "Region", "FROM", "country", "WHERE", "Name", "=", "``", "Angola", "''"], "query_toks_no_value": ["select", "population", ",", "region", "from", "country", "where", "name", "=", "value"], "question": "What region does Angola belong to and what is its population?", "question_toks": ["What", "region", "does", "Angola", "belong", "to", "and", "what", "is", "its", "population", "?"], "sql": {"from": {"table_units": [["table_unit", 2]], "conds": []}, "select": [false, [[0, [0, [0, 14, false], null]], [0, [0, [0, 11, false], null]]]], "where": [[false, 2, [0, [0, 9, false], null], "\"Angola\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "answer": [[12878000, "Central Africa"]], "results": {"generated_sql": "SELECT region ,  population FROM country WHERE name  =  'Angola'", "generated_py": "t1 = pd.merge(country, city, left_on='capital', right_on='id')\nt2 = t1[t1['name_x'] == 'Angola']\nanswer = t2[['region', 'population_y']]", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('Central Africa', 12878000)]", "py_exec_result": "           region  population_y\n2  Central Africa       2022000", "gold_answer": [[12878000, "Central Africa"]], "gold_sql": "SELECT Population ,  Region FROM country WHERE Name  =  \"Angola\"", "table_headers": {"city": ["ID", "Name", "CountryCode", "District", "Population"], "sqlite_sequence": ["name", "seq"], "country": ["Code", "Name", "Continent", "Region", "SurfaceArea", "IndepYear", "Population", "LifeExpectancy", "GNP", "GNPOld", "LocalName", "GovernmentForm", "HeadOfState", "Capital", "Code2"], "countrylanguage": ["CountryCode", "Language", "IsOfficial", "Percentage"]}, "gold_py": null}}
{"db_id": "cre_Doc_Template_Mgt", "query": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"", "query_toks": ["SELECT", "T1.template_type_code", "FROM", "Templates", "AS", "T1", "JOIN", "Documents", "AS", "T2", "ON", "T1.template_id", "=", "T2.template_id", "WHERE", "T2.document_name", "=", "``", "Data", "base", "''"], "query_toks_no_value": ["select", "t1", ".", "template_type_code", "from", "templates", "as", "t1", "join", "documents", "as", "t2", "on", "t1", ".", "template_id", "=", "t2", ".", "template_id", "where", "t2", ".", "document_name", "=", "value"], "question": "Return the template type code of the template that is used by a document named Data base.", "question_toks": ["Return", "the", "template", "type", "code", "of", "the", "template", "that", "is", "used", "by", "a", "document", "named", "Data", "base", "."], "sql": {"from": {"table_units": [["table_unit", 1], ["table_unit", 2]], "conds": [[false, 2, [0, [0, 3, false], null], [0, 10, false], null]]}, "select": [false, [[0, [0, [0, 5, false], null]]]], "where": [[false, 2, [0, [0, 11, false], null], "\"Data base\"", null]], "groupBy": [], "having": [], "orderBy": [], "limit": null, "intersect": null, "union": null, "except": null}, "db_table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "answer": [["BK"]], "results": {"generated_sql": "SELECT T1.template_type_code FROM templates AS T1 JOIN documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  'Data base'", "generated_py": "t1 = pd.merge(Documents, Templates, left_on='template_id', right_on='template_id')\nt2 = pd.merge(t1, Ref_Template_Types, left_on='template_type_code', right_on='template_type_code')\nanswer = t2[t2['document_name'] == 'Data base']['template_type_code']", "sql_error": null, "py_error": "ERROR: You are trying to merge on int64 and object columns. If you wish to proceed you should use pd.concat", "sql_exec_result": "[('BK',)]", "py_exec_result": "8    BK\nName: template_type_code, dtype: object", "gold_answer": [["BK"]], "gold_sql": "SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  \"Data base\"", "table_headers": {"Ref_Template_Types": ["Template_Type_Code", "Template_Type_Description"], "Templates": ["Template_ID", "Version_Number", "Template_Type_Code", "Date_Effective_From", "Date_Effective_To", "Template_Details"], "Documents": ["Document_ID", "Template_ID", "Document_Name", "Document_Description", "Other_Details"], "Paragraphs": ["Paragraph_ID", "Document_ID", "Paragraph_Text", "Other_Details"]}, "gold_py": null}}
